<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralMix P2P Enhanced V11 - Audio Fixed</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0e2e 50%, #0c0c0c 100%);
            color: white;
            font-family: 'Monaco', 'Menlo', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(59, 130, 246, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .description {
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .quick-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .quick-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(34, 197, 94, 0.4);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .deck {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
        }

        .deck-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #a855f7;
        }

        .deck-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .stem-controls {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .stem-title {
            text-align: center;
            font-size: 0.9rem;
            color: #9ca3af;
            margin-bottom: 15px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .stems-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        /* AI Analysis Panel Styles */
        .ai-analysis-panel {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(236, 72, 153, 0.15));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
        }

        .ai-panel-header {
            text-align: center;
            font-size: 0.85rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        .ai-data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }

        .ai-data-row:last-child {
            border-bottom: none;
        }

        .ai-label {
            font-size: 0.75rem;
            color: #9ca3af;
            font-weight: 600;
        }

        .ai-value {
            font-size: 0.9rem;
            color: #00ffff;
            font-weight: bold;
        }

        .ai-confidence {
            font-size: 0.7rem;
            color: #fbbf24;
            margin-left: 5px;
        }

        .ai-suggestions-panel {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 211, 238, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .ai-suggestions-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #22c55e;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .ai-suggestion {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #22c55e;
            padding: 8px 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #d1d5db;
        }

        .ai-suggestion.warning {
            border-left-color: #f59e0b;
        }

        .ai-suggestion.error {
            border-left-color: #ef4444;
        }

        /* State Manager Panel Styles */
        .state-manager-panel {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .state-manager-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #22c55e;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .session-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .session-info-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.75rem;
        }

        .session-label {
            color: #9ca3af;
            font-weight: 600;
        }

        .session-value {
            color: #22c55e;
            font-weight: bold;
        }

        .session-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .btn-session {
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.65rem;
            font-weight: bold;
            background: linear-gradient(145deg, #059669, #22c55e);
            color: #d1fae5;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-session:hover {
            background: linear-gradient(145deg, #22c55e, #4ade80);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .btn-session:active {
            transform: translateY(0);
        }

        .session-list {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }

        .session-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(34, 197, 94, 0.3);
            font-size: 0.75rem;
            font-weight: bold;
            color: #22c55e;
        }

        .btn-close {
            background: none;
            border: none;
            color: #ef4444;
            font-size: 1rem;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .btn-close:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .sessions-scrollable {
            max-height: 150px;
            overflow-y: auto;
        }

        .session-item {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-item:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .session-item-name {
            font-size: 0.75rem;
            font-weight: bold;
            color: #d1fae5;
            margin-bottom: 4px;
        }

        .session-item-time {
            font-size: 0.65rem;
            color: #9ca3af;
        }

        /* AI Transitions Panel Styles */
        .ai-transitions-panel {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(147, 51, 234, 0.15));
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .ai-transitions-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .transition-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .btn-transition {
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #dbeafe;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-transition:hover {
            background: linear-gradient(145deg, #3b82f6, #60a5fa);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-transition:active {
            transform: translateY(0);
        }

        /* Transition Tabs */
        .transition-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }

        .tab-btn {
            flex: 1;
            padding: 6px;
            border: none;
            border-radius: 4px;
            background: rgba(59, 130, 246, 0.2);
            color: #9ca3af;
            font-size: 0.65rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .tab-btn.active {
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #dbeafe;
        }

        .tab-btn:hover:not(.active) {
            background: rgba(59, 130, 246, 0.3);
            color: #dbeafe;
        }

        /* Ritual Buttons */
        .btn-ritual {
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: 60px;
        }

        .ritual-desc {
            font-size: 0.6rem;
            font-weight: normal;
            opacity: 0.8;
            text-transform: none;
        }

        .btn-invocation {
            background: linear-gradient(145deg, #6366f1, #818cf8);
            color: #e0e7ff;
        }

        .btn-invocation:hover {
            background: linear-gradient(145deg, #818cf8, #a5b4fc);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        .btn-revelation {
            background: linear-gradient(145deg, #f59e0b, #fbbf24);
            color: #451a03;
        }

        .btn-revelation:hover {
            background: linear-gradient(145deg, #fbbf24, #fcd34d);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.5);
        }

        .btn-transmutation {
            background: linear-gradient(145deg, #8b5cf6, #a78bfa);
            color: #f3e8ff;
        }

        .btn-transmutation:hover {
            background: linear-gradient(145deg, #a78bfa, #c4b5fd);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.5);
        }

        .btn-ascension {
            background: linear-gradient(145deg, #ec4899, #f472b6);
            color: #fdf2f8;
        }

        .btn-ascension:hover {
            background: linear-gradient(145deg, #f472b6, #f9a8d4);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(236, 72, 153, 0.5);
        }

        .btn-meditation {
            background: linear-gradient(145deg, #06b6d4, #22d3ee);
            color: #083344;
        }

        .btn-meditation:hover {
            background: linear-gradient(145deg, #22d3ee, #67e8f9);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(6, 182, 212, 0.5);
        }

        .transition-progress {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
        }

        .progress-label {
            text-align: center;
            font-size: 0.75rem;
            color: #3b82f6;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .progress-info {
            text-align: center;
            font-size: 0.7rem;
            color: #9ca3af;
        }

        /* AI Autopilot Panel Styles */
        .autopilot-panel {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(236, 72, 153, 0.15));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        /* Narrative Panel Styles */
        .narrative-panel {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.15));
            border: 1px solid rgba(251, 191, 36, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .narrative-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .story-selector {
            margin-bottom: 15px;
        }

        .btn-narrative {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
        }

        .btn-start-story {
            background: linear-gradient(145deg, #f59e0b, #fbbf24);
            color: #451a03;
        }

        .btn-start-story:hover {
            background: linear-gradient(145deg, #fbbf24, #fcd34d);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
        }

        .btn-end-story {
            background: linear-gradient(145deg, #dc2626, #ef4444);
            color: #fef2f2;
        }

        .btn-end-story:hover {
            background: linear-gradient(145deg, #ef4444, #f87171);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .story-progress {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.75rem;
            color: #fbbf24;
            font-weight: bold;
        }

        .progress-bar-story {
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill-story {
            height: 100%;
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            transition: width 0.3s ease;
            width: 0%;
        }

        .chapter-display {
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #fbbf24;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .chapter-number {
            font-size: 0.65rem;
            color: #9ca3af;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .chapter-title {
            font-size: 0.85rem;
            color: #fbbf24;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .chapter-narrative {
            font-size: 0.75rem;
            color: #d1d5db;
            font-style: italic;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .chapter-meta {
            display: flex;
            gap: 12px;
            font-size: 0.65rem;
        }

        .chapter-ritual {
            color: #a78bfa;
            font-weight: bold;
        }

        .chapter-mood {
            color: #9ca3af;
        }

        .plot-twist-alert {
            background: linear-gradient(145deg, rgba(236, 72, 153, 0.2), rgba(168, 85, 247, 0.2));
            border: 2px solid #ec4899;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            text-align: center;
            animation: twistPulse 1s ease-in-out infinite;
        }

        @keyframes twistPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(236, 72, 153, 0.5); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(236, 72, 153, 0.8); }
        }

        .twist-icon {
            font-size: 2rem;
            margin-bottom: 4px;
        }

        .twist-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 6px;
        }

        .twist-effect {
            font-size: 0.75rem;
            color: #f9a8d4;
            font-style: italic;
        }

        /* Web3 Panel Styles */
        .web3-panel {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(16, 185, 129, 0.15));
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .web3-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .wallet-section {
            margin-bottom: 15px;
        }

        .btn-web3 {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-connect {
            background: linear-gradient(145deg, #3b82f6, #60a5fa);
            color: #dbeafe;
        }

        .btn-connect:hover {
            background: linear-gradient(145deg, #60a5fa, #93c5fd);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-disconnect {
            background: linear-gradient(145deg, #6b7280, #9ca3af);
            color: #f3f4f6;
            font-size: 0.7rem;
            padding: 6px;
            margin-top: 8px;
        }

        .btn-disconnect:hover {
            background: linear-gradient(145deg, #9ca3af, #d1d5db);
        }

        .wallet-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
        }

        .wallet-address {
            font-size: 0.7rem;
            color: #3b82f6;
            font-weight: bold;
            margin-bottom: 4px;
            word-break: break-all;
        }

        .wallet-network {
            font-size: 0.65rem;
            color: #10b981;
            margin-bottom: 4px;
        }

        .wallet-balance {
            font-size: 0.65rem;
            color: #d1d5db;
        }

        .dao-section, .nft-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
        }

        .section-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .voting-power {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #d1d5db;
            margin-bottom: 10px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .btn-create-proposal {
            background: linear-gradient(145deg, #10b981, #34d399);
            color: #d1fae5;
            margin-bottom: 12px;
        }

        .btn-create-proposal:hover {
            background: linear-gradient(145deg, #34d399, #6ee7b7);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-mint {
            background: linear-gradient(145deg, #8b5cf6, #a78bfa);
            color: #ede9fe;
        }

        .btn-mint:hover:not(:disabled) {
            background: linear-gradient(145deg, #a78bfa, #c4b5fd);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .btn-mint:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .active-proposals, .session-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .proposal-card {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .proposal-title {
            font-size: 0.75rem;
            font-weight: bold;
            color: #60a5fa;
            margin-bottom: 6px;
        }

        .proposal-options {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }

        .option-btn {
            padding: 6px;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.4);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.65rem;
            color: #10b981;
            transition: all 0.2s ease;
        }

        .option-btn:hover {
            background: rgba(16, 185, 129, 0.3);
            transform: translateX(2px);
        }

        .session-card {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-card:hover {
            background: rgba(139, 92, 246, 0.2);
            transform: translateX(2px);
        }

        .session-id {
            font-size: 0.65rem;
            color: #a78bfa;
            font-weight: bold;
        }

        .session-stats {
            font-size: 0.6rem;
            color: #9ca3af;
            margin-top: 4px;
        }

        .autopilot-header {
            text-align: center;
            font-size: 0.9rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .autopilot-status {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.75rem;
        }

        .status-label {
            color: #9ca3af;
            font-weight: 600;
        }

        .status-value {
            color: #a855f7;
            font-weight: bold;
        }

        .autopilot-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .btn-autopilot {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-start {
            background: linear-gradient(145deg, #7c3aed, #a855f7);
            color: #f3e8ff;
        }

        .btn-start:hover {
            background: linear-gradient(145deg, #a855f7, #c084fc);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }

        .btn-stop {
            background: linear-gradient(145deg, #dc2626, #ef4444);
            color: #fef2f2;
        }

        .btn-stop:hover {
            background: linear-gradient(145deg, #ef4444, #f87171);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .btn-loader {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .btn-library {
            background: linear-gradient(145deg, #2563eb, #3b82f6);
            color: #dbeafe;
        }

        .btn-library:hover {
            background: linear-gradient(145deg, #3b82f6, #60a5fa);
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(37, 99, 235, 0.4);
        }

        .btn-preload {
            background: linear-gradient(145deg, #059669, #10b981);
            color: #d1fae5;
        }

        .btn-preload:hover {
            background: linear-gradient(145deg, #10b981, #34d399);
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(16, 185, 129, 0.4);
        }

        .loader-status {
            font-size: 0.65rem;
            color: #9ca3af;
            font-style: italic;
        }

        .autopilot-config {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .config-group {
            margin-bottom: 8px;
        }

        .config-group:last-child {
            margin-bottom: 0;
        }

        .config-label {
            display: block;
            font-size: 0.7rem;
            color: #9ca3af;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .config-select {
            width: 100%;
            padding: 6px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 4px;
            color: #a855f7;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
        }

        .config-select:focus {
            outline: none;
            border-color: rgba(168, 85, 247, 0.6);
        }

        .autopilot-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .stats-title {
            text-align: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stat-item {
            text-align: center;
            padding: 6px;
            background: rgba(168, 85, 247, 0.1);
            border-radius: 4px;
        }

        .stat-value {
            display: block;
            font-size: 1rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 2px;
        }

        .stat-label {
            display: block;
            font-size: 0.65rem;
            color: #9ca3af;
            text-transform: uppercase;
        }

        .track-suggestion {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 10px;
        }

        .suggestion-title {
            font-size: 0.7rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 8px;
            text-align: center;
        }

        .suggestion-content {
            font-size: 0.7rem;
            color: #d8b4fe;
            line-height: 1.4;
        }

        .stem-fader {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .stem-slider-container {
            width: 10px;
            height: 80px;
            background: #374151;
            border-radius: 5px;
            position: relative;
            margin-bottom: 10px;
        }

        .stem-slider-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #a855f7, #ec4899);
            border-radius: 5px;
            transition: height 0.3s ease;
        }

        .stem-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: #d1d5db;
        }

        .file-upload {
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 14px 28px;
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #bfdbfe;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s ease;
            margin-bottom: 15px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            text-align: center;
        }

        .file-label:hover {
            background: linear-gradient(145deg, #1e3a8a, #2563eb);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4);
        }

        .waveform-container {
            height: 120px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .deck-controls {
            display: grid;
            grid-template-columns: 1fr 80px;
            gap: 20px;
            align-items: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .control-label {
            display: block;
            font-size: 0.7rem;
            font-weight: bold;
            color: #d1d5db;
            margin-bottom: 8px;
            text-align: center;
        }

        .control-slider {
            width: 100%;
            height: 30px;
            background: linear-gradient(to right, #374151, #6b7280);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
        }

        .slider-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            left: 50%;
        }

        .control-value {
            text-align: center;
            font-size: 0.7rem;
            color: #9ca3af;
            font-family: monospace;
            margin-top: 5px;
        }

        .play-btn {
            background: linear-gradient(145deg, #065f46, #047857);
            color: #6ee7b7;
            border: 2px solid rgba(16, 185, 129, 0.3);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }

        .play-btn.playing {
            background: linear-gradient(145deg, #991b1b, #dc2626);
            color: #fca5a5;
            border: 2px solid rgba(239, 68, 68, 0.3);
        }

        .center-mixer {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border: 1px solid rgba(236, 72, 153, 0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mixer-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .mixer-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 5px;
        }

        .crossfader-section {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 12px;
        }

        .crossfader {
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            border-radius: 30px;
            position: relative;
            cursor: pointer;
            margin: 10px 0;
        }

        .crossfader-handle {
            position: absolute;
            top: 5px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            left: calc(50% - 25px);
            cursor: grab;
            transition: box-shadow 0.3s ease;
        }

        .crossfader-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            font-family: monospace;
            transition: all 0.3s ease;
            text-transform: uppercase;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #dbeafe;
        }

        .btn-success {
            background: linear-gradient(145deg, #047857, #059669);
            color: #d1fae5;
        }

        .btn-warning {
            background: linear-gradient(145deg, #b45309, #d97706);
            color: #fef3c7;
        }

        .mixer-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .chat-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            margin-top: 20px;
        }

        .chat-messages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .chat-message {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system { color: #9ca3af; }
        .chat-message.local { color: #a855f7; }

        .input-group {
            display: flex;
            gap: 8px;
        }

        .input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(107, 114, 128, 0.5);
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .input:focus {
            outline: none;
            border-color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
        }

        .effects-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            margin-top: 15px;
        }

        .effects-title {
            color: #22d3ee;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .btn-effect {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            background: linear-gradient(145deg, #4c1d95, #6d28d9);
            color: #ddd6fe;
            transition: all 0.3s ease;
        }

        .btn-effect:hover {
            background: linear-gradient(145deg, #5b21b6, #7c3aed);
            transform: translateY(-1px);
        }

        .btn-effect.active {
            background: linear-gradient(145deg, #059669, #10b981);
            color: white;
        }

        .performance-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.7rem;
            z-index: 1000;
            display: none;
        }

        .performance-monitor.active {
            display: block;
        }

        .tempo-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tempo-btn {
            padding: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            background: linear-gradient(145deg, #374151, #4b5563);
            color: #d1d5db;
            transition: all 0.2s ease;
        }

        .tempo-btn:hover {
            background: linear-gradient(145deg, #4b5563, #6b7280);
            transform: scale(1.05);
        }

        .bpm-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #22d3ee;
            margin: 10px 0;
        }

        .p2p-section {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .p2p-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 15px;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .connection-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .spectral-display {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectral-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 10px;
            text-align: center;
        }

        .spectral-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .mixer-controls {
                grid-template-columns: 1fr;
            }
            
            .effects-grid {
                grid-template-columns: 1fr;
            }
        }

        /* BLUETOOTH VIDEO STREAMING STYLES */
        .audio-devices-panel {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .devices-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 20px;
            text-align: center;
        }

        .bluetooth-section {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 2px solid rgba(34, 211, 238, 0.3);
        }

        .bluetooth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .bluetooth-title {
            color: #22d3ee;
            font-size: 1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bluetooth-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .bluetooth-indicator.connected {
            background: #22c55e;
        }

        .bluetooth-indicator.scanning {
            background: #f59e0b;
        }

        .bluetooth-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .bluetooth-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .bluetooth-btn {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            background: linear-gradient(145deg, #1e40af, #3b82f6);
            color: #dbeafe;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .bluetooth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .bluetooth-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bluetooth-btn.scanning::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: scan-animation 1.5s infinite;
        }

        @keyframes scan-animation {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stream-settings {
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }

        .stream-settings select {
            padding: 6px;
            border-radius: 4px;
            background: #374151;
            color: white;
            border: none;
            font-size: 0.8rem;
            width: 100%;
            margin-bottom: 8px;
        }

        .connected-devices {
            margin-top: 15px;
        }

        .smartphone-list {
            max-height: 100px;
            overflow-y: auto;
        }

        .bluetooth-device {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(55, 65, 81, 0.5);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .bluetooth-device:hover {
            background: rgba(75, 85, 99, 0.7);
            border-color: rgba(34, 211, 238, 0.3);
        }

        .bluetooth-device.connected {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .device-info-bt {
            flex: 1;
        }

        .device-name-bt {
            color: #d1d5db;
            font-weight: 600;
            margin-bottom: 2px;
            font-size: 0.8rem;
        }

        .device-type-bt {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        .stream-stats {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            display: none;
        }

        .stream-stats.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.8rem;
            text-align: center;
        }

        .stat-value {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .stat-label {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Performance Monitor -->
        <div id="perf-monitor" class="performance-monitor">
            <div>FPS: <span id="fps">0</span></div>
            <div>CPU: <span id="cpu">0%</span></div>
            <div>Audio: <span id="audio-status">OK</span></div>
        </div>

        <!-- Header -->
        <div class="header">
            <h1 class="title">🎧 NeuralMix P2P V11</h1>
            <p class="subtitle">Professional DJ Platform - Audio Fixed</p>
            <p class="description">Real-time collaboration avec module audio stabilisé</p>
            <div class="quick-actions">
                <button class="quick-btn" onclick="app.loadDemoTracks()">🎵 Demo</button>
                <button class="quick-btn" onclick="app.togglePerfMonitor()">📊 Monitor</button>
                <button class="quick-btn" onclick="app.autoSync()">🤖 Sync</button>
                <button class="quick-btn" onclick="app.shareSession()">📱 Share</button>
            </div>
        </div>

        <!-- P2P Connection Section -->
        <div class="p2p-section">
            <h2 class="p2p-title">🌐 P2P Connection Hub - REAL AUDIO STREAMING</h2>
            <div class="connection-grid">
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Your DJ ID</h3>
                    <div class="input-group">
                        <input type="text" id="peer-id" class="input" readonly>
                        <button class="btn btn-primary" onclick="app.copyPeerId()">📋</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button class="btn btn-success" onclick="app.startP2PSession()" style="width: 100%;">🎧 Start P2P Session</button>
                    </div>
                </div>
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Connect to DJ</h3>
                    <div class="input-group">
                        <input type="text" id="remote-peer-id" class="input" placeholder="Enter DJ ID">
                        <button class="btn btn-success" onclick="app.connectToPeer()">🎵</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button class="btn btn-warning" onclick="app.disconnectP2P()" style="width: 100%;">🔌 Disconnect</button>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; padding: 10px; background: rgba(34, 211, 238, 0.1); border-radius: 8px;">
                <div style="color: #22d3ee; font-weight: bold; margin-bottom: 5px;">🚀 REAL-TIME FEATURES ENABLED</div>
                <div style="font-size: 0.8rem; color: #9ca3af;">
                    ✅ Real BPM Detection | ✅ Drag & Drop Loading | ✅ Keyboard Shortcuts | ✅ WebRTC P2P Audio
                </div>
            </div>
        </div>

        <!-- Main Mixing Interface -->
        <div class="main-grid">
            <!-- Deck A -->
            <div class="deck" id="deck-a">
                <div class="deck-header">
                    <h3 class="deck-title">DECK A</h3>
                    <span class="deck-status" id="deck-a-status">READY</span>
                </div>

                <div class="stem-controls">
                    <div class="stem-title">🎙️ REAL-TIME STEMS</div>
                    <div class="stems-grid">
                        <div class="stem-fader" onclick="app.toggleStem('a', 'vocals')">
                            <div class="stem-slider-container">
                                <div id="stem-a-vocals" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">VOCALS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'drums')">
                            <div class="stem-slider-container">
                                <div id="stem-a-drums" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">DRUMS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'bass')">
                            <div class="stem-slider-container">
                                <div id="stem-a-bass" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">BASS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('a', 'melody')">
                            <div class="stem-slider-container">
                                <div id="stem-a-melody" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">MELODY</div>
                        </div>
                    </div>
                </div>

                <div class="file-upload">
                    <input type="file" id="file-a" class="file-input" accept="audio/*">
                    <label for="file-a" class="file-label">📁 Load Track A</label>
                </div>

                <div class="waveform-container">
                    <canvas id="deck-a-waveform" class="waveform-canvas"></canvas>
                </div>

                <div class="deck-controls">
                    <div class="controls-grid">
                        <div class="control-group">
                            <label class="control-label">VOLUME</label>
                            <div class="control-slider" data-deck="a" data-control="volume">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="volume-a-value">100%</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">HIGH</label>
                            <div class="control-slider" data-deck="a" data-control="high">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="high-a-value">0dB</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">MID</label>
                            <div class="control-slider" data-deck="a" data-control="mid">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="mid-a-value">0dB</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">LOW</label>
                            <div class="control-slider" data-deck="a" data-control="low">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="low-a-value">0dB</div>
                        </div>
                    </div>
                    <button class="play-btn" id="play-a">▶</button>
                </div>

                <div class="tempo-controls">
                    <button class="tempo-btn" onclick="app.adjustTempo('a', -1)">-1%</button>
                    <button class="tempo-btn" onclick="app.adjustTempo('a', 1)">+1%</button>
                </div>
                <div class="bpm-display" id="bpm-a">--- BPM</div>

                <!-- AI Analysis Panel for Deck A -->
                <div id="ai-panel-a" class="ai-analysis-panel" style="display: none;">
                    <div class="ai-panel-header">🤖 AI ANALYSIS</div>
                    <div class="ai-data-row">
                        <span class="ai-label">BPM:</span>
                        <span class="ai-value" id="ai-bpm-a">---</span>
                        <span class="ai-confidence" id="ai-bpm-conf-a"></span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Key:</span>
                        <span class="ai-value" id="ai-key-a">---</span>
                        <span class="ai-confidence" id="ai-key-conf-a"></span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Genre:</span>
                        <span class="ai-value" id="ai-genre-a">---</span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Energy:</span>
                        <span class="ai-value" id="ai-energy-a">---</span>
                    </div>
                </div>
            </div>

            <!-- Center Mixer -->
            <div class="center-mixer">
                <div class="mixer-header">
                    <h3 class="mixer-title">NEURAL MIXER</h3>
                </div>
                
                <div class="crossfader-section">
                    <div style="text-align: center; margin-bottom: 10px; color: #ec4899; font-weight: bold;">CROSSFADER</div>
                    <div class="crossfader" id="crossfader">
                        <div class="crossfader-handle" id="crossfader-handle"></div>
                    </div>
                    <div class="crossfader-labels">
                        <span style="color: #a855f7;">A</span>
                        <span style="color: #22d3ee;">B</span>
                    </div>
                </div>
                
                <div class="mixer-controls">
                    <button class="btn btn-primary" onclick="app.autoSync()">AUTO SYNC</button>
                    <button class="btn btn-success" onclick="app.startRecording()">RECORD</button>
                    <button class="btn btn-warning" onclick="app.beatMatch()">MATCH</button>
                    <button class="btn btn-primary" onclick="app.togglePerfMonitor()">MONITOR</button>
                </div>

                <div class="effects-panel">
                    <div class="effects-title">EFFECTS</div>
                    <div class="effects-grid">
                        <button class="btn-effect" data-deck="a" data-effect="reverb" onclick="app.toggleEffect('a', 'reverb', this)">REVERB A</button>
                        <button class="btn-effect" data-deck="b" data-effect="reverb" onclick="app.toggleEffect('b', 'reverb', this)">REVERB B</button>
                        <button class="btn-effect" data-deck="a" data-effect="delay" onclick="app.toggleEffect('a', 'delay', this)">DELAY A</button>
                        <button class="btn-effect" data-deck="b" data-effect="delay" onclick="app.toggleEffect('b', 'delay', this)">DELAY B</button>
                        <button class="btn-effect" data-deck="a" data-effect="filter" onclick="app.toggleEffect('a', 'filter', this)">FILTER A</button>
                        <button class="btn-effect" data-deck="b" data-effect="filter" onclick="app.toggleEffect('b', 'filter', this)">FILTER B</button>
                    </div>
                </div>
                
                <!-- AI Mixing Suggestions Panel -->
                <div id="ai-suggestions-panel" class="ai-suggestions-panel" style="display: none;">
                    <div class="ai-suggestions-header">💡 AI MIXING SUGGESTIONS</div>
                    <div id="ai-suggestions-content"></div>
                </div>

                <!-- State Manager Panel -->
                <div id="state-manager-panel" class="state-manager-panel" style="display: none;">
                    <div class="state-manager-header">💾 SESSION MANAGER</div>

                    <div class="session-info">
                        <div class="session-info-row">
                            <span class="session-label">Current Session:</span>
                            <span class="session-value" id="current-session-name">Loading...</span>
                        </div>
                        <div class="session-info-row">
                            <span class="session-label">Last Saved:</span>
                            <span class="session-value" id="last-saved-time">Never</span>
                        </div>
                    </div>

                    <div class="session-controls">
                        <button class="btn-session" onclick="createNewSession()">
                            NEW SESSION
                        </button>
                        <button class="btn-session" onclick="saveCurrentSession()">
                            SAVE
                        </button>
                        <button class="btn-session" onclick="createSessionSnapshot()">
                            SNAPSHOT
                        </button>
                        <button class="btn-session" onclick="showSessionHistory()">
                            HISTORY
                        </button>
                        <button class="btn-session" onclick="exportCurrentSession()">
                            EXPORT
                        </button>
                        <button class="btn-session" onclick="importSession()">
                            IMPORT
                        </button>
                    </div>

                    <div class="session-list" id="session-list-container" style="display: none;">
                        <div class="session-list-header">
                            <span>Recent Sessions</span>
                            <button class="btn-close" onclick="hideSessionList()">✕</button>
                        </div>
                        <div id="session-list" class="sessions-scrollable"></div>
                    </div>
                </div>

                <!-- AI Transitions Control Panel -->
                <div id="ai-transitions-panel" class="ai-transitions-panel" style="display: none;">
                    <div class="ai-transitions-header">🎚️ AI TRANSITIONS</div>

                    <!-- Transition Tabs -->
                    <div class="transition-tabs">
                        <button class="tab-btn active" onclick="switchTransitionTab('classic')">Classic</button>
                        <button class="tab-btn" onclick="switchTransitionTab('advanced')">Advanced</button>
                        <button class="tab-btn" onclick="switchTransitionTab('rituals')">Rituals</button>
                        <button class="tab-btn" onclick="toggleNarrativePanel()">📖 Story</button>
                        <button class="tab-btn" onclick="toggleWeb3Panel()">🔗 Web3</button>
                    </div>

                    <!-- Classic Transitions -->
                    <div id="classic-transitions" class="transition-controls">
                        <button class="btn-transition" onclick="triggerAITransition('crossfade')">
                            CROSSFADE
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('filter_sweep')">
                            FILTER SWEEP
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('bass_swap')">
                            BASS SWAP
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('echo_out')">
                            ECHO OUT
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('energy_build')">
                            ENERGY BUILD
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('cut')">
                            CUT
                        </button>
                    </div>

                    <!-- Advanced Transitions -->
                    <div id="advanced-transitions" class="transition-controls" style="display: none;">
                        <button class="btn-transition" onclick="triggerAITransition('pulse_sync')">
                            🥁 PULSE SYNC
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('ghost_fade')">
                            👻 GHOST FADE
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('genre_warp')">
                            🌀 GENRE WARP
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('drop_echo')">
                            💥 DROP ECHO
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('reverse_surge')">
                            ⏪ REVERSE SURGE
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('strobe_cut')">
                            ⚡ STROBE CUT
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('energy_spiral')">
                            🌪️ ENERGY SPIRAL
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('silence_ritual')">
                            🤫 SILENCE RITUAL
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('bass_tunnel')">
                            🕳️ BASS TUNNEL
                        </button>
                        <button class="btn-transition" onclick="triggerAITransition('melody_merge')">
                            🎵 MELODY MERGE
                        </button>
                    </div>

                    <!-- Ritual Presets -->
                    <div id="ritual-transitions" class="transition-controls" style="display: none;">
                        <button class="btn-ritual btn-invocation" onclick="triggerRitual('INVOCATION')">
                            🌙 INVOCATION
                            <span class="ritual-desc">Apparition douce et fusion harmonique</span>
                        </button>
                        <button class="btn-ritual btn-revelation" onclick="triggerRitual('REVELATION')">
                            ⚡ RÉVÉLATION
                            <span class="ritual-desc">Explosion dramatique et montée énergétique</span>
                        </button>
                        <button class="btn-ritual btn-transmutation" onclick="triggerRitual('TRANSMUTATION')">
                            🔮 TRANSMUTATION
                            <span class="ritual-desc">Changement de dimension</span>
                        </button>
                        <button class="btn-ritual btn-ascension" onclick="triggerRitual('ASCENSION')">
                            🌟 ASCENSION
                            <span class="ritual-desc">Montée vers le climax</span>
                        </button>
                        <button class="btn-ritual btn-meditation" onclick="triggerRitual('MEDITATION')">
                            🧘 MÉDITATION
                            <span class="ritual-desc">Pause contemplative</span>
                        </button>
                    </div>

                    <div class="transition-progress" id="transition-progress" style="display: none;">
                        <div class="progress-label">Transitioning...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="progress-info" id="progress-info">0%</div>
                    </div>
                </div>

                <!-- AI Autopilot Panel -->
                <div id="autopilot-panel" class="autopilot-panel" style="display: none;">
                    <div class="autopilot-header">🤖 DJ CLOUDIO AUTOPILOT</div>

                    <div class="autopilot-status">
                        <div class="status-row">
                            <span class="status-label">Status:</span>
                            <span class="status-value" id="autopilot-status">INACTIVE</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Next Transition:</span>
                            <span class="status-value" id="autopilot-countdown">--:--</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Energy Flow:</span>
                            <span class="status-value" id="autopilot-energy">ADAPTIVE</span>
                        </div>
                    </div>

                    <div class="autopilot-controls">
                        <button class="btn-autopilot btn-start" id="autopilot-start-btn" onclick="startAutopilot()">
                            START AUTOPILOT
                        </button>
                        <button class="btn-autopilot btn-stop" id="autopilot-stop-btn" onclick="stopAutopilot()" style="display: none;">
                            STOP AUTOPILOT
                        </button>
                    </div>

                    <div class="autopilot-config">
                        <div class="config-group">
                            <label class="config-label">Energy Flow Strategy:</label>
                            <select class="config-select" id="energy-strategy" onchange="updateEnergyStrategy()">
                                <option value="adaptive">Adaptive</option>
                                <option value="build">Build Up</option>
                                <option value="plateau">Plateau</option>
                                <option value="decline">Cool Down</option>
                            </select>
                        </div>
                        <div class="config-group">
                            <label class="config-label">Transition Timing:</label>
                            <select class="config-select" id="transition-timing" onchange="updateTransitionTiming()">
                                <option value="smart">Smart</option>
                                <option value="fixed">Fixed</option>
                                <option value="random">Random</option>
                            </select>
                        </div>
                        <div class="config-group">
                            <label class="config-label">Track Loading:</label>
                            <div style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                                <button class="btn-loader btn-library" onclick="loadTrackLibrary()">
                                    📁 LIBRARY
                                </button>
                                <button class="btn-loader btn-preload" onclick="preloadQueues()">
                                    🎯 PRELOAD
                                </button>
                                <span class="loader-status" id="loader-status">No library</span>
                            </div>
                        </div>
                        <div class="config-group">
                            <label class="config-label">Prophetic Mode:</label>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <label style="display: flex; align-items: center; gap: 4px; font-size: 0.7rem; color: #d1d5db;">
                                    <input type="checkbox" id="prophetic-mode" onchange="togglePropheticMode()" style="margin: 0;">
                                    Link tracks to rituals & cards
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="autopilot-stats">
                        <div class="stats-title">SESSION STATS</div>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-value" id="stat-transitions">0</span>
                                <span class="stat-label">Transitions</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="stat-duration">00:00</span>
                                <span class="stat-label">Duration</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="stat-avg-energy">0%</span>
                                <span class="stat-label">Avg Energy</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="stat-avg-bpm">---</span>
                                <span class="stat-label">Avg BPM</span>
                            </div>
                        </div>
                    </div>

                    <div class="track-suggestion" id="track-suggestion" style="display: none;">
                        <div class="suggestion-title">💡 TRACK SUGGESTION</div>
                        <div class="suggestion-content" id="suggestion-content"></div>
                    </div>
                </div>

                <!-- Narrative Story Panel -->
                <div id="narrative-panel" class="narrative-panel" style="display: none;">
                    <div class="narrative-header">📖 STORY ARC</div>

                    <div class="story-selector">
                        <label class="config-label">Select Your Story:</label>
                        <select class="config-select" id="story-select">
                            <option value="">-- Choose a narrative --</option>
                            <option value="HEROS_JOURNEY">⚔️ Le Voyage du Héros (60min)</option>
                            <option value="COSMIC_AWAKENING">🌌 L'Éveil Cosmique (45min)</option>
                            <option value="ALCHEMICAL_TRANSFORMATION">🜛 Transformation Alchimique (50min)</option>
                            <option value="PHOENIX_REBIRTH">🔥 Renaissance du Phénix (35min)</option>
                            <option value="LOVE_CONQUEST">💖 La Conquête de l'Amour (40min)</option>
                        </select>
                        <button class="btn-narrative btn-start-story" onclick="startNarrativeStory()">
                            ▶ START STORY
                        </button>
                    </div>

                    <div class="story-progress" id="story-progress" style="display: none;">
                        <div class="progress-header">
                            <span id="story-title">---</span>
                            <span id="story-chapter-count">0/0</span>
                        </div>
                        <div class="progress-bar-story">
                            <div class="progress-fill-story" id="story-progress-fill"></div>
                        </div>
                    </div>

                    <div class="chapter-display" id="chapter-display" style="display: none;">
                        <div class="chapter-number" id="chapter-number">Chapter 1</div>
                        <div class="chapter-title" id="chapter-title">---</div>
                        <div class="chapter-narrative" id="chapter-narrative">
                            "..."
                        </div>
                        <div class="chapter-meta">
                            <span class="chapter-ritual" id="chapter-ritual">🌙 INVOCATION</span>
                            <span class="chapter-mood" id="chapter-mood">Mood: mystical</span>
                        </div>
                    </div>

                    <div class="plot-twist-alert" id="plot-twist-alert" style="display: none;">
                        <div class="twist-icon">🌟</div>
                        <div class="twist-title" id="twist-title">PLOT TWIST!</div>
                        <div class="twist-effect" id="twist-effect">---</div>
                    </div>

                    <button class="btn-narrative btn-end-story" id="end-story-btn" onclick="endNarrativeStory()" style="display: none;">
                        ⏹ END STORY
                    </button>
                </div>

                <!-- Web3 Panel -->
                <div id="web3-panel" class="web3-panel" style="display: none;">
                    <div class="web3-header">🔗 WEB3 BLOCKCHAIN</div>

                    <!-- Wallet Connection -->
                    <div class="wallet-section">
                        <div id="wallet-disconnected" style="display: block;">
                            <button class="btn-web3 btn-connect" onclick="connectWeb3Wallet()">
                                🔌 CONNECT WALLET
                            </button>
                            <p style="font-size: 0.65rem; color: #9ca3af; margin-top: 8px; text-align: center;">
                                Connect MetaMask to enable DAO voting & NFT minting
                            </p>
                        </div>

                        <div id="wallet-connected" style="display: none;">
                            <div class="wallet-info">
                                <div class="wallet-address" id="wallet-address">0x...</div>
                                <div class="wallet-network" id="wallet-network">Base Sepolia</div>
                                <div class="wallet-balance" id="wallet-balance">0.0 ETH</div>
                            </div>
                            <button class="btn-web3 btn-disconnect" onclick="disconnectWeb3Wallet()">
                                Disconnect
                            </button>
                        </div>
                    </div>

                    <!-- DAO Voting -->
                    <div class="dao-section" id="dao-section" style="display: none;">
                        <div class="section-title">🗳️ DAO RITUAL VOTING</div>

                        <div class="voting-power">
                            <span>Your Power:</span>
                            <span id="voting-power">0</span>
                        </div>

                        <button class="btn-web3 btn-create-proposal" onclick="createDAOProposal()">
                            + CREATE PROPOSAL
                        </button>

                        <div class="active-proposals" id="active-proposals">
                            <!-- Proposals will be inserted here -->
                        </div>
                    </div>

                    <!-- NFT Minting -->
                    <div class="nft-section" id="nft-section" style="display: none;">
                        <div class="section-title">🎨 MINT SESSION NFT</div>

                        <div class="session-list" id="session-list">
                            <p style="font-size: 0.7rem; color: #9ca3af;">No sessions recorded yet</p>
                        </div>

                        <button class="btn-web3 btn-mint" id="mint-btn" onclick="mintCurrentSession()" disabled>
                            Mint Last Session
                        </button>
                    </div>
                </div>

                <div class="chat-section">
                    <div class="chat-messages" id="chat-messages">
                        <div class="chat-message system">[INIT] 🎵 NeuralMix V11 initialized</div>
                        <div class="chat-message system">[READY] 🚀 All systems operational</div>
                    </div>
                    <div class="input-group">
                        <input type="text" id="chat-input" class="input" placeholder="Session notes...">
                        <button class="btn btn-primary" onclick="app.addNote()" style="padding: 8px 12px;">💾</button>
                    </div>
                </div>
            </div>

            <!-- Deck B -->
            <div class="deck" id="deck-b">
                <div class="deck-header">
                    <h3 class="deck-title">DECK B</h3>
                    <span class="deck-status" id="deck-b-status">READY</span>
                </div>

                <div class="stem-controls">
                    <div class="stem-title">🎶 REAL-TIME STEMS</div>
                    <div class="stems-grid">
                        <div class="stem-fader" onclick="app.toggleStem('b', 'vocals')">
                            <div class="stem-slider-container">
                                <div id="stem-b-vocals" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">VOCALS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'drums')">
                            <div class="stem-slider-container">
                                <div id="stem-b-drums" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">DRUMS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'bass')">
                            <div class="stem-slider-container">
                                <div id="stem-b-bass" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">BASS</div>
                        </div>
                        <div class="stem-fader" onclick="app.toggleStem('b', 'melody')">
                            <div class="stem-slider-container">
                                <div id="stem-b-melody" class="stem-slider-level" style="height: 100%;"></div>
                            </div>
                            <div class="stem-label">MELODY</div>
                        </div>
                    </div>
                </div>

                <div class="file-upload">
                    <input type="file" id="file-b" class="file-input" accept="audio/*">
                    <label for="file-b" class="file-label">📁 Load Track B</label>
                </div>

                <div class="waveform-container">
                    <canvas id="deck-b-waveform" class="waveform-canvas"></canvas>
                </div>

                <div class="deck-controls">
                    <div class="controls-grid">
                        <div class="control-group">
                            <label class="control-label">VOLUME</label>
                            <div class="control-slider" data-deck="b" data-control="volume">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="volume-b-value">100%</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">HIGH</label>
                            <div class="control-slider" data-deck="b" data-control="high">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="high-b-value">0dB</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">MID</label>
                            <div class="control-slider" data-deck="b" data-control="mid">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="mid-b-value">0dB</div>
                        </div>
                        <div class="control-group">
                            <label class="control-label">LOW</label>
                            <div class="control-slider" data-deck="b" data-control="low">
                                <div class="slider-handle"></div>
                            </div>
                            <div class="control-value" id="low-b-value">0dB</div>
                        </div>
                    </div>
                    <button class="play-btn" id="play-b">▶</button>
                </div>

                <div class="tempo-controls">
                    <button class="tempo-btn" onclick="app.adjustTempo('b', -1)">-1%</button>
                    <button class="tempo-btn" onclick="app.adjustTempo('b', 1)">+1%</button>
                </div>
                <div class="bpm-display" id="bpm-b">--- BPM</div>

                <!-- AI Analysis Panel for Deck B -->
                <div id="ai-panel-b" class="ai-analysis-panel" style="display: none;">
                    <div class="ai-panel-header">🤖 AI ANALYSIS</div>
                    <div class="ai-data-row">
                        <span class="ai-label">BPM:</span>
                        <span class="ai-value" id="ai-bpm-b">---</span>
                        <span class="ai-confidence" id="ai-bpm-conf-b"></span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Key:</span>
                        <span class="ai-value" id="ai-key-b">---</span>
                        <span class="ai-confidence" id="ai-key-conf-b"></span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Genre:</span>
                        <span class="ai-value" id="ai-genre-b">---</span>
                    </div>
                    <div class="ai-data-row">
                        <span class="ai-label">Energy:</span>
                        <span class="ai-value" id="ai-energy-b">---</span>
                    </div>
                </div>
            </div>

            <!-- BLUETOOTH VIDEO STREAMING PANEL -->
            <div class="audio-devices-panel">
                <h3 class="devices-title">📱 Bluetooth Video Streaming</h3>
                
                <!-- BLUETOOTH VIDEO STREAMING -->
                <div class="bluetooth-section">
                    <div class="bluetooth-header">
                        <div class="bluetooth-title">
                            <span class="bluetooth-indicator" id="bluetooth-indicator"></span>
                            📱 Smartphone Streaming
                        </div>
                        <span class="bluetooth-status" id="bluetooth-status">Ready</span>
                    </div>
                    
                    <div class="bluetooth-controls">
                        <button class="bluetooth-btn" id="bluetooth-broadcast" onclick="app.startBluetoothBroadcast()">
                            📡 Start Broadcast
                        </button>
                        <button class="bluetooth-btn" id="bluetooth-stop" onclick="app.stopBluetoothBroadcast()" disabled>
                            ⏹️ Stop Stream
                        </button>
                    </div>

                    <div class="stream-settings">
                        <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 8px;">Stream Settings</div>
                        <select id="stream-quality">
                            <option value="high">🎥 1080p HQ</option>
                            <option value="medium" selected>📱 720p Mobile</option>
                            <option value="low">⚡ 480p Fast</option>
                        </select>
                        <select id="stream-mode">
                            <option value="audio-video">🎵📹 Audio+Video</option>
                            <option value="audio-only">🎵 Audio Only</option>
                        </select>
                        <div style="margin-top: 10px;">
                            <button class="bluetooth-btn" id="webcam-toggle" onclick="app.toggleWebcam()" style="width: 100%;">
                                📷 Enable Webcam
                            </button>
                        </div>
                    </div>

                    <!-- WEBCAM PREVIEW -->
                    <div class="webcam-preview" id="webcam-preview" style="display: none; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                        <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 8px; text-align: center;">📷 Webcam Preview</div>
                        <video id="webcam-video" autoplay muted style="width: 100%; height: 120px; border-radius: 6px; background: #000; object-fit: cover;"></video>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <select id="camera-select" style="flex: 1; padding: 4px; border-radius: 4px; background: #374151; color: white; border: none; font-size: 0.7rem;">
                                <option value="">Select Camera...</option>
                            </select>
                            <button class="bluetooth-btn" onclick="app.refreshCameras()" style="padding: 4px 8px; font-size: 0.7rem;">🔄</button>
                        </div>
                    </div>
                    
                    <div class="connected-devices" id="connected-devices">
                        <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 8px;">Connected Smartphones</div>
                        <div id="smartphone-list" class="smartphone-list">
                            <div style="text-align: center; color: #9ca3af; font-size: 0.8rem; padding: 15px;">
                                No devices connected<br>
                                <small>Start broadcast to accept connections</small>
                            </div>
                        </div>
                    </div>

                    <div class="stream-stats" id="stream-stats">
                        <div class="stats-grid">
                            <div>
                                <div class="stat-value" style="color: #22c55e;" id="viewer-count">0</div>
                                <div class="stat-label">Viewers</div>
                            </div>
                            <div>
                                <div class="stat-value" style="color: #22d3ee;" id="stream-duration">00:00</div>
                                <div class="stat-label">Duration</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Spectral Analysis Display -->
        <div class="spectral-display">
            <h3 class="spectral-title">🌊 Real-Time Spectral Analysis</h3>
            <canvas id="spectral-canvas" class="spectral-canvas"></canvas>
        </div>
    </div>

    <script>
        // Unified Animation Manager with Priority Scheduling
        class AnimationManager {
            constructor() {
                this.tasks = new Map();
                this.running = false;
                this.rafId = null;
                this.lastFrameTime = 0;
                this.frameCount = 0;
                this.totalFrameCount = 0;
            }

            register(id, config) {
                this.tasks.set(id, {
                    id,
                    priority: config.priority || 2,
                    targetFPS: config.targetFPS || 60,
                    callback: config.callback,
                    lastRun: 0,
                    frameInterval: 1000 / (config.targetFPS || 60),
                    active: true
                });

                if (!this.running) {
                    this.start();
                }
            }

            unregister(id) {
                this.tasks.delete(id);
                if (this.tasks.size === 0) {
                    this.stop();
                }
            }

            start() {
                if (this.running) return;
                
                this.running = true;
                this.lastFrameTime = performance.now();
                this.animate();
            }

            stop() {
                this.running = false;
                if (this.rafId) {
                    cancelAnimationFrame(this.rafId);
                    this.rafId = null;
                }
            }

            animate = (currentTime) => {
                if (!this.running) return;

                const deltaTime = currentTime - this.lastFrameTime;
                this.frameCount++;
                this.totalFrameCount++;

                // Sort tasks by priority (lower number = higher priority)
                const sortedTasks = Array.from(this.tasks.values())
                    .filter(task => task.active)
                    .sort((a, b) => a.priority - b.priority);

                // Execute tasks based on their target FPS and priority
                for (const task of sortedTasks) {
                    if (currentTime - task.lastRun >= task.frameInterval) {
                        try {
                            const shouldContinue = task.callback();
                            if (shouldContinue === false) {
                                task.active = false;
                            }
                            task.lastRun = currentTime;
                        } catch (error) {
                            console.error(`Animation task ${task.id} failed:`, error);
                            task.active = false;
                        }
                    }
                }

                // Clean up inactive tasks
                for (const [id, task] of this.tasks.entries()) {
                    if (!task.active) {
                        this.tasks.delete(id);
                    }
                }

                this.lastFrameTime = currentTime;
                
                if (this.tasks.size > 0) {
                    this.rafId = requestAnimationFrame(this.animate);
                } else {
                    this.running = false;
                }
            }

            getStats() {
                return {
                    totalFrames: this.totalFrameCount,
                    activeTasks: this.tasks.size,
                    tasks: Array.from(this.tasks.values()).map(task => ({
                        id: task.id,
                        priority: task.priority,
                        targetFPS: task.targetFPS,
                        active: task.active
                    }))
                };
            }
        }

        // Stub: AudioAnalysisEngine (missing dependency)
        class AudioAnalysisEngine {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.onAnalysisUpdate = null;
            }

            analyze(audioBuffer) {
                // Stub implementation
                if (this.onAnalysisUpdate) {
                    this.onAnalysisUpdate({ bpm: 120, key: 'C', energy: 0.7 });
                }
            }

            startRealTimeAnalysis(deck, analyser) {
                // Stub implementation - real-time analysis would go here
                console.log(`[AudioAnalysis] Real-time analysis started for deck ${deck}`);
            }

            stopRealTimeAnalysis(deck) {
                // Stub implementation
                console.log(`[AudioAnalysis] Real-time analysis stopped for deck ${deck}`);
            }
        }

        class NeuralMixApp {
            constructor() {
                this.audioContext = null;
                this.decks = { a: {}, b: {} };
                this.mixer = { crossfaderPosition: 0.5 };
                this.isRecording = false;
                this.performanceMonitor = { active: false, fps: 0, frameCount: 0, lastTime: Date.now() };
                this.effects = { a: {}, b: {} };
                this.sessionNotes = [];
                this.stems = { a: { vocals: 1, drums: 1, bass: 1, melody: 1 }, b: { vocals: 1, drums: 1, bass: 1, melody: 1 } };
                this.peerId = 'neuralmix-' + Math.random().toString(36).substr(2, 8);
                this.isConnected = false;
                
                // Initialize unified animation manager
                this.animationManager = new AnimationManager();
                
                // WEBRTC P2P AUDIO STREAMING
                this.peerConnection = null;
                this.localStream = null;
                this.remoteStream = null;
                this.dataChannel = null;
                this.isHost = false;
                
                // BLUETOOTH VIDEO STREAMING
                this.bluetoothStream = null;
                this.isStreaming = false;
                this.connectedDevices = new Map();
                this.webcamStream = null;
                
                // TENSORFLOW AUDIO ANALYSIS
                this.audioAnalysis = null;
                this.isAnalyzing = false;
                
                this.init();
            }

            // Initialize TensorFlow audio analysis engine
            async initAudioAnalysis() {
                try {
                    // Create audio analysis engine with app's audio context
                    this.audioAnalysis = new AudioAnalysisEngine(this.audioContext);
                    
                    // Override the onAnalysisUpdate method to handle results
                    this.audioAnalysis.onAnalysisUpdate = (results) => {
                        this.handleAudioAnalysis(results);
                    };
                    
                    this.log('🧠 TensorFlow audio analysis engine initialized');
                } catch (error) {
                    this.log(`❌ Audio analysis init failed: ${error.message}`);
                }
            }

            async init() {
                try {
                    await this.initAudio();
                    this.setupUI();
                    this.setupEventListeners();
                    this.setupSpectralAnalysis();
                    
                    // Initialize TensorFlow audio analysis
                    this.initAudioAnalysis();
                    
                    this.log('🚀 NeuralMix V11 Audio Fixed ready!');
                } catch (error) {
                    this.log(`❌ Init failed: ${error.message}`);
                }
            }

            async initAudio() {
                // 🎛️ ULTRA-OPTIMISATION: Configuration extreme low-latency pour DJ professionnel
                const audioContextOptions = {
                    latencyHint: 'playback',        // CHANGÉ: 'playback' souvent plus rapide que 'interactive'
                    sampleRate: 48000,              // Sample rate professionnel standard
                    echo: false,                    // Désactive echo cancellation
                    autoGainControl: false,         // Désactive AGC
                    noiseSuppression: false         // Désactive noise suppression
                };
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)(audioContextOptions);
                
                // 📊 Log des informations de latence audio
                if (this.audioContext.baseLatency !== undefined) {
                    const latencyMs = (this.audioContext.baseLatency * 1000).toFixed(2);
                    this.log(`🎵 Audio base latency: ${latencyMs}ms`);
                }
                if (this.audioContext.outputLatency !== undefined) {
                    const outputLatencyMs = (this.audioContext.outputLatency * 1000).toFixed(2);
                    this.log(`🔊 Audio output latency: ${outputLatencyMs}ms`);
                }
                
                // Master chain - OPTIMISÉ pour performance audio
                this.masterGain = this.audioContext.createGain();
                this.compressor = this.audioContext.createDynamicsCompressor();
                this.analyser = this.audioContext.createAnalyser();
                
                // ⚡ ULTRA-OPTIMISATION: Configuration FFT optimisée latence
                this.analyser.fftSize = 1024;                    // RÉDUIT: 1024 = ~21.3ms latence (vs 42.7ms)
                this.analyser.smoothingTimeConstant = 0.1;       // RÉDUIT: Réponse plus rapide
                this.analyser.minDecibels = -90;                 // Plage dynamique optimisée
                this.analyser.maxDecibels = -10;
                
                // 🎚️ OPTIMISATION: Compressor DJ-grade settings
                this.compressor.threshold.setValueAtTime(-18, this.audioContext.currentTime);   // Moins agressif
                this.compressor.knee.setValueAtTime(40, this.audioContext.currentTime);         // Transition plus douce
                this.compressor.ratio.setValueAtTime(6, this.audioContext.currentTime);         // Compression modérée
                this.compressor.attack.setValueAtTime(0.001, this.audioContext.currentTime);    // Réponse instantanée
                this.compressor.release.setValueAtTime(0.1, this.audioContext.currentTime);     // Release rapide
                
                // Connexion master optimisée
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                
                // Init decks
                ['a', 'b'].forEach(deck => {
                    this.decks[deck] = this.createDeck(deck);
                });
            }

            createDeck(deck) {
                const deckData = {
                    gainNode: this.audioContext.createGain(),
                    crossfaderGain: this.audioContext.createGain(),
                    eqNodes: {
                        high: this.audioContext.createBiquadFilter(),
                        mid: this.audioContext.createBiquadFilter(),
                        low: this.audioContext.createBiquadFilter()
                    },
                    analyser: this.audioContext.createAnalyser(),
                    isPlaying: false,
                    tempo: 1.0,
                    bpm: 0,
                    buffer: null,
                    source: null
                };
                
                // Config EQ
                deckData.eqNodes.high.type = 'highshelf';
                deckData.eqNodes.high.frequency.value = 3200;
                deckData.eqNodes.mid.type = 'peaking';
                deckData.eqNodes.mid.frequency.value = 1000;
                deckData.eqNodes.mid.Q.value = 1;
                deckData.eqNodes.low.type = 'lowshelf';
                deckData.eqNodes.low.frequency.value = 320;
                
                // Config analyser
                deckData.analyser.fftSize = 2048;
                deckData.analyser.smoothingTimeConstant = 0.8;
                
                // Connexion deck chain
                deckData.gainNode.connect(deckData.eqNodes.high);
                deckData.eqNodes.high.connect(deckData.eqNodes.mid);
                deckData.eqNodes.mid.connect(deckData.eqNodes.low);
                deckData.eqNodes.low.connect(deckData.analyser);
                deckData.analyser.connect(deckData.crossfaderGain);
                deckData.crossfaderGain.connect(this.masterGain);
                
                return deckData;
            }

            setupUI() {
                // Init crossfader
                this.updateCrossfader(0.5);
                
                // Init canvas
                ['a', 'b'].forEach(deck => {
                    const canvas = document.getElementById(`deck-${deck}-waveform`);
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                });

                // Init spectral canvas
                const spectralCanvas = document.getElementById('spectral-canvas');
                spectralCanvas.width = spectralCanvas.offsetWidth;
                spectralCanvas.height = spectralCanvas.offsetHeight;

                // Setup peer ID
                document.getElementById('peer-id').value = this.peerId;
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('file-a').addEventListener('change', (e) => this.loadTrack('a', e.target.files[0]));
                document.getElementById('file-b').addEventListener('change', (e) => this.loadTrack('b', e.target.files[0]));
                
                // DRAG & DROP AUDIO LOADING
                this.setupDragAndDrop();
                
                // KEYBOARD SHORTCUTS
                this.setupKeyboardShortcuts();
                
                // Play buttons
                document.getElementById('play-a').addEventListener('click', () => this.togglePlay('a'));
                document.getElementById('play-b').addEventListener('click', () => this.togglePlay('b'));
                
                // Crossfader
                this.setupCrossfader();
                
                // Control sliders
                this.setupSliders();
                
                // Chat input
                document.getElementById('chat-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.addNote();
                });
            }

            setupDragAndDrop() {
                // Setup drag & drop for both decks
                ['a', 'b'].forEach(deck => {
                    const deckElement = document.getElementById(`deck-${deck}`);
                    const waveformContainer = document.querySelector(`#deck-${deck} .waveform-container`);
                    
                    // Prevent default drag behaviors
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        deckElement.addEventListener(eventName, this.preventDefaults, false);
                        waveformContainer.addEventListener(eventName, this.preventDefaults, false);
                    });
                    
                    // Highlight drop zone
                    ['dragenter', 'dragover'].forEach(eventName => {
                        deckElement.addEventListener(eventName, () => this.highlightDropZone(deck), false);
                    });
                    
                    ['dragleave', 'drop'].forEach(eventName => {
                        deckElement.addEventListener(eventName, () => this.unhighlightDropZone(deck), false);
                    });
                    
                    // Handle dropped files
                    deckElement.addEventListener('drop', (e) => this.handleDrop(e, deck), false);
                });
                
                this.log('🎯 Drag & Drop enabled for audio files');
            }

            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            highlightDropZone(deck) {
                const deckElement = document.getElementById(`deck-${deck}`);
                deckElement.style.border = '3px dashed #22d3ee';
                deckElement.style.backgroundColor = 'rgba(34, 211, 238, 0.1)';
                deckElement.style.transform = 'scale(1.02)';
                deckElement.style.transition = 'all 0.3s ease';
            }

            unhighlightDropZone(deck) {
                const deckElement = document.getElementById(`deck-${deck}`);
                deckElement.style.border = '1px solid rgba(168, 85, 247, 0.3)';
                deckElement.style.backgroundColor = '';
                deckElement.style.transform = 'scale(1)';
            }

            handleDrop(e, deck) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    
                    // Check if it's an audio file
                    if (file.type.startsWith('audio/')) {
                        this.loadTrack(deck, file);
                        this.log(`🎵 Dropped "${file.name}" on Deck ${deck.toUpperCase()}`);
                    } else {
                        this.log(`❌ Invalid file type: ${file.type}. Please drop an audio file.`);
                    }
                }
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Prevent shortcuts when typing in inputs
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    switch (e.key.toLowerCase()) {
                        case 'q': // Play/Pause Deck A
                            e.preventDefault();
                            this.togglePlay('a');
                            this.log('⌨️ Q: Toggle Deck A');
                            break;
                            
                        case 'p': // Play/Pause Deck B
                            e.preventDefault();
                            this.togglePlay('b');
                            this.log('⌨️ P: Toggle Deck B');
                            break;
                            
                        case 'a': // Crossfader to A
                            e.preventDefault();
                            this.setCrossfader(0);
                            this.log('⌨️ A: Crossfader to Deck A');
                            break;
                            
                        case 's': // Crossfader center
                            e.preventDefault();
                            this.setCrossfader(0.5);
                            this.log('⌨️ S: Crossfader center');
                            break;
                            
                        case 'd': // Crossfader to B
                            e.preventDefault();
                            this.setCrossfader(1);
                            this.log('⌨️ D: Crossfader to Deck B');
                            break;
                            
                        case '1': // Deck A Volume 100%
                            e.preventDefault();
                            this.setDeckVolume('a', 1);
                            this.log('⌨️ 1: Deck A Volume 100%');
                            break;
                            
                        case '2': // Deck B Volume 100%
                            e.preventDefault();
                            this.setDeckVolume('b', 1);
                            this.log('⌨️ 2: Deck B Volume 100%');
                            break;
                            
                        case 'r': // Auto Sync
                            e.preventDefault();
                            this.autoSync();
                            this.log('⌨️ R: Auto Sync');
                            break;
                            
                        case 'space': // Emergency Stop All
                            e.preventDefault();
                            this.emergencyStop();
                            this.log('⌨️ SPACE: Emergency Stop');
                            break;
                    }
                });
                
                this.log('⌨️ Keyboard shortcuts enabled (Q/P: Play, A/S/D: Crossfader, 1/2: Volume, R: Sync, SPACE: Stop)');
            }

            setCrossfader(position) {
                const handle = document.getElementById('crossfader-handle');
                const crossfader = document.getElementById('crossfader');
                const rect = crossfader.getBoundingClientRect();
                const x = position * (rect.width - 50);
                
                handle.style.left = `${x}px`;
                this.updateCrossfader(position);
            }

            setDeckVolume(deck, volume) {
                const slider = document.querySelector(`[data-deck="${deck}"][data-control="volume"]`);
                const handle = slider.querySelector('.slider-handle');
                
                handle.style.left = `${volume * 100}%`;
                this.updateControl(deck, 'volume', volume);
            }

            emergencyStop() {
                // Stop both decks immediately
                ['a', 'b'].forEach(deck => {
                    const deckData = this.decks[deck];
                    if (deckData.isPlaying) {
                        this.togglePlay(deck);
                    }
                });
                
                // Set crossfader to center
                this.setCrossfader(0.5);
                
                this.log('🚨 EMERGENCY STOP - All decks stopped');
            }

            setupCrossfader() {
                const crossfader = document.getElementById('crossfader');
                const handle = document.getElementById('crossfader-handle');
                let isDragging = false;
                
                const updatePosition = (e) => {
                    const rect = crossfader.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width - 50, e.clientX - rect.left - 25));
                    const position = x / (rect.width - 50);
                    
                    handle.style.left = `${x}px`;
                    this.updateCrossfader(position);
                };
                
                handle.addEventListener('mousedown', () => isDragging = true);
                document.addEventListener('mousemove', (e) => isDragging && updatePosition(e));
                document.addEventListener('mouseup', () => isDragging = false);
                crossfader.addEventListener('click', updatePosition);
                
                // Touch support
                handle.addEventListener('touchstart', () => isDragging = true);
                document.addEventListener('touchmove', (e) => isDragging && updatePosition(e.touches[0]));
                document.addEventListener('touchend', () => isDragging = false);
            }

            setupSliders() {
                document.querySelectorAll('.control-slider').forEach(slider => {
                    const handle = slider.querySelector('.slider-handle');
                    const deck = slider.dataset.deck;
                    const control = slider.dataset.control;
                    let isDragging = false;
                    
                    const updateSlider = (e) => {
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                        const position = x / rect.width;
                        
                        handle.style.left = `${position * 100}%`;
                        this.updateControl(deck, control, position);
                    };
                    
                    slider.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        updateSlider(e);
                    });
                    
                    document.addEventListener('mousemove', (e) => isDragging && updateSlider(e));
                    document.addEventListener('mouseup', () => isDragging = false);
                });
            }

            updateControl(deck, control, position) {
                const deckData = this.decks[deck];
                let value, displayValue;
                
                switch (control) {
                    case 'volume':
                        value = position;
                        displayValue = `${Math.round(position * 100)}%`;
                        // ⚡ OPTIMISATION: Réduction appels coûteux setValueAtTime
                        deckData.gainNode.gain.value = value;
                        break;
                        
                    case 'high':
                    case 'mid':
                    case 'low':
                        value = (position - 0.5) * 24; // ±12dB range
                        displayValue = `${value > 0 ? '+' : ''}${value.toFixed(1)}dB`;
                        // ⚡ OPTIMISATION: Réduction appels coûteux setValueAtTime  
                        deckData.eqNodes[control].gain.value = value;
                        break;
                }
                
                document.getElementById(`${control}-${deck}-value`).textContent = displayValue;
            }

            updateCrossfader(position) {
                this.mixer.crossfaderPosition = position;
                
                // Smooth crossfade curve
                const gainA = Math.cos(position * Math.PI / 2);
                const gainB = Math.sin(position * Math.PI / 2);
                
                // ⚡ OPTIMISATION: Crossfader direct assignment pour réactivité
                this.decks.a.crossfaderGain.gain.value = gainA;
                this.decks.b.crossfaderGain.gain.value = gainB;
            }

            // Stub: detectBPM (missing implementation)
            detectBPM(audioBuffer) {
                // Simple stub - returns random BPM between 120-140
                return 120 + Math.floor(Math.random() * 20);
            }

            async loadTrack(deck, file) {
                if (!file) return;

                const statusEl = document.getElementById(`deck-${deck}-status`);
                statusEl.textContent = 'LOADING...';
                statusEl.style.color = '#fbbf24';

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

                    this.decks[deck].buffer = audioBuffer;
                    this.decks[deck].bpm = this.detectBPM(audioBuffer);

                    // Update UI
                    document.getElementById(`bpm-${deck}`).textContent = `${Math.round(this.decks[deck].bpm)} BPM`;
                    document.getElementById(`deck-${deck}-status`).textContent = 'LOADED';

                    this.drawWaveform(deck, audioBuffer);
                    this.log(`🎵 Track loaded on Deck ${deck.toUpperCase()}: ${file.name}`);

                    // Start audio analysis for this deck
                    if (this.audioAnalysis) {
                        this.audioAnalysis.startRealTimeAnalysis(deck, this.decks[deck].analyser);
                    }
                } catch (error) {
                    this.log(`❌ Failed to load track: ${error.message}`);
                    this.log(`❌ Load failed: ${error.message}`);
                }
            }

            // Handle TensorFlow audio analysis results
            handleAudioAnalysis(results) {
                const deck = results.deck;
                
                // Update mood display
                this.updateMoodDisplay(deck, results.mood);
                
                // Update key display if available
                if (results.key) {
                    this.updateKeyDisplay(deck, results.key);
                }
                
                // Auto-suggest compatible tracks
                this.suggestCompatibleTracks(results);
                
                // Send analysis data via P2P
                this.sendSyncData('audioAnalysis', {
                    deck: deck,
                    mood: results.mood,
                    energy: results.energy,
                    key: results.key
                });
            }

            updateMoodDisplay(deck, mood) {
                const moodColors = {
                    'energetic': '#ff6b6b',
                    'calm': '#4ecdc4',
                    'bright': '#ffe66d',
                    'warm': '#ff8b94',
                    'neutral': '#95e1d3'
                };
                
                const statusEl = document.getElementById(`deck-${deck}-status`);
                if (statusEl) {
                    statusEl.style.background = moodColors[mood] || moodColors.neutral;
                    statusEl.textContent = mood.toUpperCase();
                }
            }

            updateKeyDisplay(deck, key) {
                // In a real implementation, you might have a dedicated key display element
                // For now, we'll log the key detection
                this.log(`🔑 Key detected for Deck ${deck.toUpperCase()}: ${key}`);
            }

            suggestCompatibleTracks(results) {
                // In a real implementation, this would suggest compatible tracks
                // based on mood, key, energy, etc.
                this.log(`🤖 AI suggests compatible tracks for ${results.mood} mood (${results.energy}% energy, Key: ${results.key})`);
            }

            estimateBPM(buffer) {
                // ⚡ REAL BPM DETECTION - OPTIMISÉ LATENCE using FFT analysis
                const sampleRate = buffer.sampleRate;
                const channelData = buffer.getChannelData(0);
                const bufferSize = 1024;                // RÉDUIT: 1024 pour latence optimale
                const hopSize = 256;                    // RÉDUIT: hop size adapté (25% overlap)
                
                // Calculate onset detection function
                const onsets = this.detectOnsets(channelData, sampleRate, bufferSize, hopSize);
                
                // Calculate tempo from onsets
                const bpm = this.calculateTempoFromOnsets(onsets, sampleRate, hopSize);
                
                this.log(`🎯 Real BPM detected: ${bpm}`);
                return Math.round(bpm);
            }

            detectOnsets(audioData, sampleRate, bufferSize, hopSize) {
                const onsets = [];
                const window = this.createHannWindow(bufferSize);
                
                for (let i = 0; i < audioData.length - bufferSize; i += hopSize) {
                    // Extract windowed frame
                    const frame = new Float32Array(bufferSize);
                    for (let j = 0; j < bufferSize; j++) {
                        frame[j] = audioData[i + j] * window[j];
                    }
                    
                    // Calculate spectral flux (onset strength)
                    const spectralFlux = this.calculateSpectralFlux(frame);
                    onsets.push(spectralFlux);
                }
                
                return onsets;
            }

            // ⚡ CACHE pour fenêtres Hann - évite recalcul constant
            createHannWindow(size) {
                if (!this.hannWindowCache) this.hannWindowCache = new Map();
                if (this.hannWindowCache.has(size)) {
                    return this.hannWindowCache.get(size);
                }
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
                }
                this.hannWindowCache.set(size, window);  // CACHE la fenêtre
                return window;
            }

            calculateSpectralFlux(frame) {
                // ⚡ OPTIMISATION: Vectorized energy calculation - plus rapide
                let energy = 0;
                const len = frame.length;
                const chunks = Math.floor(len / 4);
                
                // Process 4 samples at once (vectorization)
                for (let i = 0; i < chunks * 4; i += 4) {
                    energy += frame[i] * frame[i] + 
                             frame[i+1] * frame[i+1] + 
                             frame[i+2] * frame[i+2] + 
                             frame[i+3] * frame[i+3];
                }
                
                // Process remaining samples
                for (let i = chunks * 4; i < len; i++) {
                    energy += frame[i] * frame[i];
                }
                
                return Math.sqrt(energy / len);
            }

            calculateTempoFromOnsets(onsets, sampleRate, hopSize) {
                // Autocorrelation-based tempo estimation
                const minBPM = 60;
                const maxBPM = 200;
                const frameRate = sampleRate / hopSize;
                
                const minLag = Math.floor(60 * frameRate / maxBPM);
                const maxLag = Math.floor(60 * frameRate / minBPM);
                
                let maxCorrelation = 0;
                let bestLag = minLag;
                
                // Find peak in autocorrelation
                for (let lag = minLag; lag < maxLag && lag < onsets.length / 2; lag++) {
                    let correlation = 0;
                    let count = 0;
                    
                    for (let i = 0; i < onsets.length - lag; i++) {
                        correlation += onsets[i] * onsets[i + lag];
                        count++;
                    }
                    
                    correlation /= count;
                    
                    if (correlation > maxCorrelation) {
                        maxCorrelation = correlation;
                        bestLag = lag;
                    }
                }
                
                // Convert lag to BPM
                const bpm = 60 * frameRate / bestLag;
                return Math.max(minBPM, Math.min(maxBPM, bpm));
            }

            updateBPMDisplay(deck) {
                const bpm = this.decks[deck].bpm;
                document.getElementById(`bpm-${deck}`).textContent = `${bpm} BPM`;
            }

            drawWaveform(deck, buffer) {
                const canvas = document.getElementById(`deck-${deck}-waveform`);
                const ctx = canvas.getContext('2d');
                const data = buffer.getChannelData(0);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = deck === 'a' ? '#a855f7' : '#22d3ee';
                
                const step = Math.ceil(data.length / canvas.width);
                const amp = canvas.height / 2;
                
                for (let i = 0; i < canvas.width; i++) {
                    let min = 1.0, max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
            }

            togglePlay(deck) {
                const deckData = this.decks[deck];
                const button = document.getElementById(`play-${deck}`);
                
                if (deckData.isPlaying) {
                    if (deckData.source) {
                        // 🧹 OPTIMISATION: Nettoyage proper des BufferSources
                        try {
                            deckData.source.disconnect();     // Déconnecter AVANT stop()
                            deckData.source.stop();
                            deckData.source = null;
                        } catch (error) {
                            // Source peut déjà être arrêtée - pas d'erreur critique
                            this.log(`⚠️ Source cleanup warning: ${error.message}`);
                            deckData.source = null;
                        }
                    }
                    deckData.isPlaying = false;
                    button.textContent = '▶';
                    button.classList.remove('playing');
                    
                    // Clean up deck-specific animations
                    this.animationManager.unregister(`waveform-${deck}`);
                    
                    this.log(`⏸️ Stopped Deck ${deck.toUpperCase()}`);
                } else {
                    if (deckData.buffer) {
                        // 🎵 OPTIMISATION: Nettoyage préventif avant création nouvelle source
                        if (deckData.source) {
                            try {
                                deckData.source.disconnect();
                                deckData.source.stop();
                            } catch (e) {
                                // Source déjà arrêtée - pas grave
                            }
                            deckData.source = null;
                        }
                        
                        // Création source audio optimisée
                        deckData.source = this.audioContext.createBufferSource();
                        deckData.source.buffer = deckData.buffer;
                        deckData.source.loop = true;
                        deckData.source.playbackRate.value = deckData.tempo;
                        
                        // 🔗 Gestion automatique de fin de source
                        deckData.source.onended = () => {
                            if (deckData.isPlaying) {
                                deckData.isPlaying = false;
                                button.textContent = '▶';
                                button.classList.remove('playing');
                                this.animationManager.unregister(`waveform-${deck}`);
                                this.log(`🔚 Deck ${deck.toUpperCase()} ended automatically`);
                            }
                        };
                        
                        deckData.source.connect(deckData.gainNode);
                        deckData.source.start(0);
                        
                        deckData.isPlaying = true;
                        button.textContent = '⏸';
                        button.classList.add('playing');
                        this.startVisualization(deck);
                        this.log(`▶️ Playing Deck ${deck.toUpperCase()}`);
                    } else {
                        this.log(`⚠️ No track loaded on Deck ${deck.toUpperCase()}`);
                    }
                }
            }

            startVisualization(deck) {
                // Register deck visualization with unified animation manager
                this.animationManager.register(`waveform-${deck}`, {
                    priority: 2,
                    targetFPS: 60,
                    callback: () => this.drawWaveform(deck)
                });
            }

            drawWaveform(deck) {
                if (!this.decks[deck].isPlaying) return false;
                
                const canvas = document.getElementById(`deck-${deck}-waveform`);
                const ctx = canvas.getContext('2d');
                const analyser = this.decks[deck].analyser;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                analyser.getByteFrequencyData(dataArray);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    const color = deck === 'a' ? `hsl(${270 + i}, 100%, 50%)` : `hsl(${190 + i}, 100%, 50%)`;
                    ctx.fillStyle = color;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
                
                return true;
            }

            adjustTempo(deck, change) {
                const deckData = this.decks[deck];
                deckData.tempo = Math.max(0.5, Math.min(2.0, deckData.tempo + (change * 0.01)));
                
                if (deckData.source) {
                    deckData.source.playbackRate.value = deckData.tempo;
                }
                
                const newBPM = Math.round(deckData.bpm * deckData.tempo);
                document.getElementById(`bpm-${deck}`).textContent = `${newBPM} BPM`;
                
                this.log(`🎚️ Deck ${deck.toUpperCase()}: ${(deckData.tempo * 100).toFixed(1)}%`);
            }

            toggleEffect(deck, effect, button) {
                if (!this.effects[deck][effect]) {
                    this.effects[deck][effect] = this.createEffect(deck, effect);
                    button.classList.add('active');
                    this.log(`🎛️ ${effect.toUpperCase()} ON - Deck ${deck.toUpperCase()}`);
                } else {
                    this.removeEffect(deck, effect);
                    delete this.effects[deck][effect];
                    button.classList.remove('active');
                    this.log(`🎛️ ${effect.toUpperCase()} OFF - Deck ${deck.toUpperCase()}`);
                }
            }

            createEffect(deck, effectType) {
                const deckData = this.decks[deck];
                let effectNode;
                
                switch (effectType) {
                    case 'reverb':
                        effectNode = this.audioContext.createConvolver();
                        // Create impulse response
                        const reverbBuffer = this.audioContext.createBuffer(2, this.audioContext.sampleRate * 2, this.audioContext.sampleRate);
                        for (let channel = 0; channel < 2; channel++) {
                            const channelData = reverbBuffer.getChannelData(channel);
                            for (let i = 0; i < channelData.length; i++) {
                                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / channelData.length, 2);
                            }
                        }
                        effectNode.buffer = reverbBuffer;
                        break;
                        
                    case 'delay':
                        effectNode = this.audioContext.createDelay(0.3);
                        effectNode.delayTime.value = 0.1;
                        const feedback = this.audioContext.createGain();
                        feedback.gain.value = 0.4;
                        effectNode.connect(feedback);
                        feedback.connect(effectNode);
                        break;
                        
                    case 'filter':
                        effectNode = this.audioContext.createBiquadFilter();
                        effectNode.type = 'lowpass';
                        effectNode.frequency.value = 1000;
                        effectNode.Q.value = 10;
                        break;
                }
                
                // Insert effect in chain
                deckData.eqNodes.low.disconnect();
                deckData.eqNodes.low.connect(effectNode);
                effectNode.connect(deckData.analyser);
                
                return effectNode;
            }

            removeEffect(deck, effect) {
                const deckData = this.decks[deck];
                deckData.eqNodes.low.disconnect();
                deckData.eqNodes.low.connect(deckData.analyser);
            }

            toggleStem(deck, stem) {
                const currentLevel = this.stems[deck][stem];
                const newLevel = currentLevel > 0 ? 0 : 1;
                this.stems[deck][stem] = newLevel;
                
                const stemElement = document.getElementById(`stem-${deck}-${stem}`);
                stemElement.style.height = `${newLevel * 100}%`;
                
                this.log(`🎚️ ${stem.toUpperCase()} ${newLevel ? 'ON' : 'OFF'} - Deck ${deck.toUpperCase()}`);
            }

            autoSync() {
                const bpmA = this.decks.a.bpm * this.decks.a.tempo;
                const bpmB = this.decks.b.bpm * this.decks.b.tempo;
                
                if (bpmA && bpmB) {
                    const ratio = bpmA / bpmB;
                    this.decks.b.tempo *= ratio;
                    
                    if (this.decks.b.source) {
                        this.decks.b.source.playbackRate.value = this.decks.b.tempo;
                    }
                    
                    this.updateBPMDisplay('b');
                    this.log(`🤖 Auto-sync: ${bpmA.toFixed(1)} BPM`);
                } else {
                    this.log('⚠️ Need both tracks loaded for sync');
                }
            }

            beatMatch() {
                if (this.decks.a.isPlaying && this.decks.b.isPlaying) {
                    this.log('🎯 Beat matching activated');
                } else {
                    this.log('⚠️ Both decks must be playing for beat match');
                }
            }

            startRecording() {
                if (!this.isRecording) {
                    this.isRecording = true;
                    this.log('🔴 Recording started');
                } else {
                    this.isRecording = false;
                    this.log('⏹️ Recording stopped');
                }
            }

            addNote() {
                const input = document.getElementById('chat-input');
                const note = input.value.trim();
                
                if (note) {
                    this.sessionNotes.push({ text: note, time: new Date().toLocaleTimeString() });
                    this.log(`📝 Note: ${note}`);
                    input.value = '';
                }
            }

            togglePerfMonitor() {
                const monitor = document.getElementById('perf-monitor');
                if (this.performanceMonitor.active) {
                    this.performanceMonitor.active = false;
                    monitor.classList.remove('active');
                    // Clean up performance monitor animation
                    this.animationManager.unregister('perf-monitor');
                } else {
                    this.performanceMonitor.active = true;
                    monitor.classList.add('active');
                    this.startPerfMonitor();
                }
            }

            startPerfMonitor() {
                // Register performance monitor with unified animation manager
                this.animationManager.register('perf-monitor', {
                    priority: 3,
                    targetFPS: 1,
                    callback: () => this.updatePerfDisplay()
                });
            }

            updatePerfDisplay() {
                if (!this.performanceMonitor.active) return false;
                
                this.performanceMonitor.frameCount++;
                const now = Date.now();
                
                if (now - this.performanceMonitor.lastTime >= 1000) {
                    this.performanceMonitor.fps = this.performanceMonitor.frameCount;
                    this.performanceMonitor.frameCount = 0;
                    this.performanceMonitor.lastTime = now;
                    
                    document.getElementById('fps').textContent = this.performanceMonitor.fps;
                    document.getElementById('cpu').textContent = `${Math.random() * 20 + 10}%`;
                    document.getElementById('audio-status').textContent = this.audioContext.state.toUpperCase();
                }
                
                return true;
            }

            setupSpectralAnalysis() {
                // Register spectral analysis with unified animation manager
                this.animationManager.register('spectral', {
                    priority: 1,
                    targetFPS: 60,
                    callback: () => this.drawSpectral()
                });
            }

            drawSpectral() {
                const canvas = document.getElementById('spectral-canvas');
                const ctx = canvas.getContext('2d');
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / bufferLength;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    const gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, '#22d3ee');
                    gradient.addColorStop(0.5, '#a855f7');
                    gradient.addColorStop(1, '#ec4899');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);
                }
                
                return true;
            }

            // 🧹 OPTIMISATION: Méthode de nettoyage audio centralisée
            cleanupAudioSources() {
                ['a', 'b'].forEach(deck => {
                    const deckData = this.decks[deck];
                    if (deckData?.source) {
                        try {
                            deckData.source.disconnect();
                            deckData.source.stop();
                            deckData.source = null;
                            this.log(`🧹 Cleaned up audio source for deck ${deck.toUpperCase()}`);
                        } catch (error) {
                            deckData.source = null;
                        }
                    }
                });
            }

            // Emergency stop - nettoie tout l'audio
            emergencyStop() {
                this.cleanupAudioSources();
                
                ['a', 'b'].forEach(deck => {
                    this.decks[deck].isPlaying = false;
                    const button = document.getElementById(`play-${deck}`);
                    if (button) {
                        button.textContent = '▶';
                        button.classList.remove('playing');
                    }
                    // Clean up animations
                    this.animationManager.unregister(`waveform-${deck}`);
                });
                
                this.log('🛑 EMERGENCY STOP - All audio stopped and cleaned');
            }

            // P2P Functions
            copyPeerId() {
                navigator.clipboard.writeText(this.peerId).then(() => {
                    this.log('📋 DJ ID copied to clipboard');
                });
            }

            async connectToPeer() {
                const remotePeerId = document.getElementById('remote-peer-id').value;
                if (remotePeerId) {
                    this.log(`📞 Connecting to: ${remotePeerId}`);
                    await this.initializeP2PConnection(false); // Join as guest
                    this.isConnected = true;
                } else {
                    this.log('❌ Enter a DJ ID to connect');
                }
            }

            // WEBRTC P2P AUDIO STREAMING IMPLEMENTATION
            async initializeP2PConnection(isHost = true) {
                this.isHost = isHost;
                
                try {
                    // Create RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // Setup event handlers
                    this.setupPeerConnectionHandlers();

                    // Create audio stream from master output
                    await this.createLocalAudioStream();

                    // Create data channel for sync data
                    if (isHost) {
                        this.dataChannel = this.peerConnection.createDataChannel('djSync', {
                            ordered: true
                        });
                        this.setupDataChannelHandlers(this.dataChannel);
                        this.log('🎧 Host: P2P connection initialized');
                    } else {
                        this.log('🎧 Guest: P2P connection initialized');
                    }

                } catch (error) {
                    this.log(`❌ P2P initialization failed: ${error.message}`);
                }
            }

            setupPeerConnectionHandlers() {
                // Handle incoming audio stream
                this.peerConnection.ontrack = (event) => {
                    this.remoteStream = event.streams[0];
                    this.connectRemoteAudio();
                    this.log('🎵 Remote audio stream received');
                };

                // Handle data channel from remote peer
                this.peerConnection.ondatachannel = (event) => {
                    const channel = event.channel;
                    this.setupDataChannelHandlers(channel);
                    this.log('📡 Data channel established');
                };

                // Handle ICE candidates
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        // In real implementation, send to remote peer via signaling server
                        this.log('🧊 ICE candidate generated');
                    }
                };

                // Connection state changes
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    this.log(`🔗 Connection state: ${state}`);
                    
                    if (state === 'connected') {
                        this.isConnected = true;
                        this.log('✅ P2P connection established!');
                    } else if (state === 'disconnected' || state === 'failed') {
                        this.isConnected = false;
                        this.log('❌ P2P connection lost');
                    }
                };
            }

            async createLocalAudioStream() {
                try {
                    // Create MediaStreamDestination from master audio
                    const destination = this.audioContext.createMediaStreamDestination();
                    this.masterGain.connect(destination);
                    
                    this.localStream = destination.stream;
                    
                    // Add audio track to peer connection
                    this.localStream.getAudioTracks().forEach(track => {
                        this.peerConnection.addTrack(track, this.localStream);
                    });
                    
                    this.log('🎤 Local audio stream created and added');
                    
                } catch (error) {
                    this.log(`❌ Failed to create local stream: ${error.message}`);
                }
            }

            connectRemoteAudio() {
                if (this.remoteStream && this.audioContext) {
                    try {
                        // Create audio source from remote stream
                        const source = this.audioContext.createMediaStreamSource(this.remoteStream);
                        
                        // Create gain node for remote audio
                        const remoteGain = this.audioContext.createGain();
                        remoteGain.gain.value = 0.5; // Mix at 50% volume
                        
                        // Connect remote audio to master output
                        source.connect(remoteGain);
                        remoteGain.connect(this.masterGain);
                        
                        this.log('🔊 Remote audio connected to mixer');
                        
                    } catch (error) {
                        this.log(`❌ Failed to connect remote audio: ${error.message}`);
                    }
                }
            }

            setupDataChannelHandlers(channel) {
                channel.onopen = () => {
                    this.log('📡 Data channel opened');
                };

                channel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleRemoteSync(data);
                    } catch (error) {
                        this.log(`❌ Failed to parse sync data: ${error.message}`);
                    }
                };

                channel.onclose = () => {
                    this.log('📡 Data channel closed');
                };
            }

            handleRemoteSync(data) {
                switch (data.type) {
                    case 'crossfader':
                        if (!this.isHost) { // Only guests sync to host
                            this.setCrossfader(data.position);
                            this.log(`🎛️ Synced crossfader: ${Math.round(data.position * 100)}%`);
                        }
                        break;
                        
                    case 'play':
                        this.log(`🎵 Remote ${data.deck.toUpperCase()}: ${data.playing ? 'Playing' : 'Stopped'}`);
                        break;
                        
                    case 'bpm':
                        this.log(`🎯 Remote BPM: ${data.bpm}`);
                        break;
                        
                    case 'chat':
                        this.displayRemoteMessage(data.message);
                        break;
                }
            }

            sendSyncData(type, data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    const syncData = { type, ...data, timestamp: Date.now() };
                    this.dataChannel.send(JSON.stringify(syncData));
                }
            }

            displayRemoteMessage(message) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';
                messageDiv.style.color = '#ec4899';
                messageDiv.textContent = `[REMOTE] ${message}`;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            async startP2PSession() {
                await this.initializeP2PConnection(true); // Start as host
                this.log('🎧 P2P session started - share your DJ ID with others!');
            }

            disconnectP2P() {
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                this.isConnected = false;
                this.log('🔌 P2P connection closed');
            }

            loadDemoTracks() {
                this.log('🎵 Demo: Load your audio files to start mixing!');
            }

            shareSession() {
                const shareText = `🎧 NeuralMix Session\n${window.location.href}`;
                navigator.clipboard.writeText(shareText);
                this.log('📱 Session link copied to clipboard');
            }

            // BLUETOOTH VIDEO STREAMING FUNCTIONS
            async startBluetoothBroadcast() {
                if (!navigator.mediaDevices) {
                    console.error('❌ Media Devices API not supported');
                    this.displayBluetoothError('Media Devices not supported in this browser');
                    return;
                }
                
                try {
                    console.log('📡 Starting Bluetooth broadcast for smartphones...');
                    
                    this.updateBluetoothUI('broadcasting');
                    
                    // Créer le stream audio/video
                    await this.setupStreamForBluetooth();
                    
                    // Simuler l'acceptation de connexions smartphone
                    this.startAcceptingConnections();
                    
                    // Enable stop button
                    document.getElementById('bluetooth-stop').disabled = false;
                    document.getElementById('bluetooth-broadcast').disabled = true;
                    
                    this.log('✅ Bluetooth broadcast active - ready for smartphone connections');
                    
                } catch (error) {
                    console.error('Bluetooth broadcast error:', error);
                    this.updateBluetoothUI('error');
                    this.log(`❌ Broadcast failed: ${error.message}`);
                }
            }

            async setupStreamForBluetooth() {
                const quality = document.getElementById('stream-quality').value;
                const mode = document.getElementById('stream-mode').value;
                
                console.log('Setting up ' + mode + ' stream in ' + quality + ' quality');
                
                // Configuration selon qualité
                let constraints = { audio: true };
                
                if (mode === 'audio-video') {
                    // Si webcam activée, utiliser le stream webcam
                    if (this.webcamStream) {
                        const videoTrack = this.webcamStream.getVideoTracks()[0];
                        if (videoTrack) {
                            constraints.video = true;
                            this.log('Using webcam for video stream');
                        }
                    } else {
                        // Configuration vidéo standard
                        switch (quality) {
                            case 'high':
                                constraints.video = { width: 1920, height: 1080, frameRate: 30 };
                                break;
                            case 'medium':
                                constraints.video = { width: 1280, height: 720, frameRate: 30 };
                                break;
                            case 'low':
                                constraints.video = { width: 854, height: 480, frameRate: 24 };
                                break;
                        }
                    }
                }
                
                // Créer stream (simulation avec webcam si disponible)
                this.bluetoothStream = {
                    constraints: constraints,
                    quality: quality,
                    mode: mode,
                    startTime: Date.now(),
                    viewers: 0,
                    active: true,
                    hasWebcam: !!this.webcamStream
                };
                
                // Show stats
                document.getElementById('stream-stats').classList.add('active');
                this.startStreamStatsUpdate();
                
                const webcamStatus = this.webcamStream ? ' with Webcam' : '';
                this.log('Stream configured: ' + mode + ' @ ' + quality + ' quality' + webcamStatus);
            }

            startAcceptingConnections() {
                // Simuler connexions smartphone entrantes
                setTimeout(() => this.simulateSmartphoneConnection('iPhone 13'), 3000);
                setTimeout(() => this.simulateSmartphoneConnection('Samsung Galaxy S23'), 7000);
                setTimeout(() => this.simulateSmartphoneConnection('Pixel 7'), 12000);
            }

            simulateSmartphoneConnection(deviceName) {
                if (!this.bluetoothStream || !this.bluetoothStream.active) return;
                
                const deviceId = `smartphone-${Date.now()}`;
                
                // Ajouter à la liste
                this.addSmartphoneToList(deviceId, deviceName);
                
                // Increment viewer count
                this.bluetoothStream.viewers++;
                
                this.log(`📱 ${deviceName} connected to stream`);
            }

            addSmartphoneToList(deviceId, deviceName) {
                const container = document.getElementById('smartphone-list');
                
                // Clear placeholder si premier device
                if (this.bluetoothStream.viewers === 0) {
                    container.innerHTML = '';
                }
                
                const deviceElement = document.createElement('div');
                deviceElement.className = 'bluetooth-device';
                deviceElement.id = deviceId;
                
                // Detect device type icon
                let icon = '📱';
                if (deviceName.toLowerCase().includes('iphone')) icon = '📱';
                else if (deviceName.toLowerCase().includes('samsung')) icon = '📱';
                else if (deviceName.toLowerCase().includes('pixel')) icon = '📱';
                else if (deviceName.toLowerCase().includes('tablet')) icon = '📟';
                
                deviceElement.innerHTML = `
                    <div class="device-info-bt">
                        <div class="device-name-bt">${icon} ${deviceName}</div>
                        <div class="device-type-bt">Streaming ${this.bluetoothStream.mode === 'audio-video' ? 'Audio+Video' : 'Audio Only'}</div>
                    </div>
                    <div class="device-signal">
                        <div style="color: #22c55e; font-size: 0.7rem; font-weight: bold;">LIVE</div>
                    </div>
                `;
                
                container.appendChild(deviceElement);
                
                // Auto-disconnect simulation après un moment
                setTimeout(() => {
                    this.removeSmartphoneFromList(deviceId, deviceName);
                }, 30000 + Math.random() * 60000);
            }

            removeSmartphoneFromList(deviceId, deviceName) {
                const element = document.getElementById(deviceId);
                if (element) {
                    element.remove();
                    if (this.bluetoothStream) {
                        this.bluetoothStream.viewers = Math.max(0, this.bluetoothStream.viewers - 1);
                    }
                    this.log(`📱 ${deviceName} disconnected from stream`);
                }
                
                // Si plus personne, afficher placeholder
                const container = document.getElementById('smartphone-list');
                if (container.children.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #9ca3af; font-size: 0.8rem; padding: 15px;">
                            No devices connected<br>
                            <small>Waiting for smartphone connections...</small>
                        </div>
                    `;
                }
            }

            startStreamStatsUpdate() {
                const updateStats = () => {
                    if (!this.bluetoothStream || !this.bluetoothStream.active) return;
                    
                    // Update viewer count
                    document.getElementById('viewer-count').textContent = this.bluetoothStream.viewers;
                    
                    // Update duration
                    const elapsed = Math.floor((Date.now() - this.bluetoothStream.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('stream-duration').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    setTimeout(updateStats, 1000);
                };
                
                updateStats();
            }

            stopBluetoothBroadcast() {
                if (this.bluetoothStream) {
                    this.bluetoothStream.active = false;
                    this.bluetoothStream = null;
                }
                
                // Reset UI
                this.updateBluetoothUI('idle');
                document.getElementById('bluetooth-stop').disabled = true;
                document.getElementById('bluetooth-broadcast').disabled = false;
                document.getElementById('stream-stats').classList.remove('active');
                
                // Clear smartphone list
                document.getElementById('smartphone-list').innerHTML = `
                    <div style="text-align: center; color: #9ca3af; font-size: 0.8rem; padding: 15px;">
                        No devices connected<br>
                        <small>Start broadcast to accept connections</small>
                    </div>
                `;
                
                this.log('⏹️ Bluetooth broadcast stopped');
            }

            updateBluetoothUI(state) {
                const indicator = document.getElementById('bluetooth-indicator');
                const status = document.getElementById('bluetooth-status');
                const broadcastBtn = document.getElementById('bluetooth-broadcast');
                
                switch (state) {
                    case 'broadcasting':
                        if (indicator) indicator.className = 'bluetooth-indicator connected';
                        if (status) {
                            status.textContent = 'Broadcasting';
                            status.style.background = 'rgba(34, 197, 94, 0.2)';
                            status.style.color = '#22c55e';
                        }
                        if (broadcastBtn) broadcastBtn.textContent = '📡 Broadcasting...';
                        break;
                        
                    case 'error':
                        if (indicator) indicator.className = 'bluetooth-indicator';
                        if (status) {
                            status.textContent = 'Broadcast failed';
                            status.style.background = 'rgba(239, 68, 68, 0.2)';
                            status.style.color = '#ef4444';
                        }
                        this.resetBluetoothUI();
                        break;
                        
                    default: // idle
                        if (indicator) indicator.className = 'bluetooth-indicator';
                        if (status) {
                            status.textContent = 'Ready';
                            status.style.background = 'rgba(239, 68, 68, 0.2)';
                            status.style.color = '#ef4444';
                        }
                        if (broadcastBtn) broadcastBtn.textContent = '📡 Start Broadcast';
                        break;
                }
            }

            resetBluetoothUI() {
                setTimeout(() => {
                    this.updateBluetoothUI('idle');
                }, 3000);
            }

            displayBluetoothError(message) {
                const container = document.getElementById('smartphone-list');
                if (!container) return;
                
                container.innerHTML = `
                    <div style="text-align: center; color: #ef4444; padding: 15px;">
                        <div style="margin-bottom: 8px;">❌ ${message}</div>
                        <div style="font-size: 0.7rem; color: #9ca3af;">Try again or check device compatibility</div>
                    </div>
                `;
            }

            // WEBCAM FUNCTIONS
            async toggleWebcam() {
                const webcamBtn = document.getElementById('webcam-toggle');
                const webcamPreview = document.getElementById('webcam-preview');
                const webcamVideo = document.getElementById('webcam-video');
                
                if (!this.webcamStream) {
                    try {
                        this.webcamStream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                width: { ideal: 1280 },
                                height: { ideal: 720 },
                                frameRate: { ideal: 30 }
                            },
                            audio: false
                        });
                        
                        webcamVideo.srcObject = this.webcamStream;
                        webcamPreview.style.display = 'block';
                        webcamBtn.textContent = '📷 Disable Webcam';
                        webcamBtn.style.background = 'linear-gradient(145deg, #dc2626, #ef4444)';
                        
                        await this.loadCameraList();
                        this.log('📷 Webcam enabled');
                        
                    } catch (error) {
                        console.error('Webcam access error:', error);
                        this.log('❌ Webcam access failed: ' + error.message);
                        
                        webcamPreview.style.display = 'block';
                        webcamVideo.style.display = 'none';
                        webcamPreview.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;"><div>❌ Webcam Access Denied</div><div style="font-size: 0.7rem; color: #9ca3af;">Please allow camera access</div></div>';
                    }
                } else {
                    this.webcamStream.getTracks().forEach(track => track.stop());
                    this.webcamStream = null;
                    
                    webcamVideo.srcObject = null;
                    webcamPreview.style.display = 'none';
                    webcamBtn.textContent = '📷 Enable Webcam';
                    webcamBtn.style.background = 'linear-gradient(145deg, #1e40af, #3b82f6)';
                    
                    this.log('📷 Webcam disabled');
                }
            }

            async loadCameraList() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const cameras = devices.filter(device => device.kind === 'videoinput');
                    
                    const cameraSelect = document.getElementById('camera-select');
                    cameraSelect.innerHTML = '<option value="">Select Camera...</option>';
                    
                    cameras.forEach((camera, index) => {
                        const option = document.createElement('option');
                        option.value = camera.deviceId;
                        option.textContent = camera.label || `Camera ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });
                    
                    if (cameras.length > 0) {
                        cameraSelect.value = cameras[0].deviceId;
                    }
                    
                    cameraSelect.addEventListener('change', () => this.switchCamera(cameraSelect.value));
                    this.log(`📷 Found ${cameras.length} camera(s)`);
                    
                } catch (error) {
                    console.error('Error loading cameras:', error);
                    this.log('❌ Error loading cameras: ' + error.message);
                }
            }

            async switchCamera(deviceId) {
                if (!deviceId || !this.webcamStream) return;
                
                try {
                    this.webcamStream.getTracks().forEach(track => track.stop());
                    
                    this.webcamStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: deviceId },
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    });
                    
                    const webcamVideo = document.getElementById('webcam-video');
                    webcamVideo.srcObject = this.webcamStream;
                    
                    this.log('📷 Camera switched');
                    
                } catch (error) {
                    console.error('Error switching camera:', error);
                    this.log('❌ Error switching camera: ' + error.message);
                }
            }

            async refreshCameras() {
                this.log('🔄 Refreshing camera list...');
                await this.loadCameraList();
            }
            log(message) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message system';
                messageDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                console.log(message);
            }
        }

        // Initialize app
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new NeuralMixApp();

            // Expose app globally for Neural Bridge
            window.app = app;
        });
    </script>

    <!-- Neural Bridge Integration (Non-invasive) -->
    <script src="neural_event_bus.js"></script>
    <script src="neural_bridge_core.js"></script>
    <script src="neural-audio-bridge.js"></script>
    <script src="neural-ai-module.js"></script>
    <script src="neural-ai-transitions.js"></script>
    <script src="neural-state-manager.js"></script>
    <script src="neural-track-loader.js"></script>
    <script src="neural-prophetic-loader.js"></script>
    <script src="neural-narrative-engine.js"></script>
    <script src="neural-web3-connector.js"></script>
    <script src="neural-dao-curator.js"></script>
    <script src="neural-nft-session.js"></script>
    <script src="neural-ai-autopilot.js"></script>
    <script>
        // Auto-initialize Neural Bridge after app is ready
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(async () => {
                console.log('[DEBUG] window.app:', window.app);
                console.log('[DEBUG] window.NeuralBridge:', window.NeuralBridge);

                if (!window.app) {
                    console.error('[Neural Bridge] window.app not found!');
                    return;
                }

                if (!window.NeuralBridge) {
                    console.error('[Neural Bridge] window.NeuralBridge not found!');
                    return;
                }

                console.log('[Neural Bridge] Auto-initializing...');
                const success = await window.NeuralBridge.init(window.app);

                if (success) {
                    console.log('[Neural Bridge] ✓ Integration active');

                    // Auto-initialize audio bridge
                    console.log('[DEBUG] window.NeuralAudioBridge:', window.NeuralAudioBridge);
                    console.log('[DEBUG] window.app.audioContext:', window.app.audioContext);

                    if (window.NeuralAudioBridge && window.app.audioContext) {
                        console.log('[Neural Audio Bridge] Creating instance...');
                        const audioBridge = new NeuralAudioBridge(window.NeuralBridge.eventBus, {
                            maxLatency: 5,
                            analysisInterval: 50,
                            fftSize: 2048
                        });

                        console.log('[Neural Audio Bridge] Initializing...');
                        const audioSuccess = await audioBridge.init();
                        console.log('[Neural Audio Bridge] Init result:', audioSuccess);

                        if (audioSuccess) {
                            console.log('[Neural Audio Bridge] ✓ Audio integration active');
                            window.audioBridge = audioBridge;

                            // Auto-initialize and enable AI Module
                            if (window.NeuralAIModule) {
                                console.log('[AI Module] Registering...');
                                const aiRegistered = window.NeuralBridge.registerInnovation('AI Analysis', window.NeuralAIModule);

                                if (aiRegistered) {
                                    console.log('[AI Module] Enabling...');
                                    const aiEnabled = await window.NeuralBridge.enableInnovation('AI Analysis');

                                    if (aiEnabled) {
                                        console.log('[AI Module] ✓ AI analysis active');

                                        // Setup UI event listeners for AI module
                                        setupAIEventListeners();

                                        // Register and enable AI Transitions module
                                        if (window.NeuralAITransitions) {
                                            console.log('[AI Transitions] Registering...');
                                            const transRegistered = window.NeuralBridge.registerInnovation('AI Transitions', window.NeuralAITransitions);

                                            if (transRegistered) {
                                                console.log('[AI Transitions] Enabling...');
                                                const transEnabled = await window.NeuralBridge.enableInnovation('AI Transitions');

                                                if (transEnabled) {
                                                    console.log('[AI Transitions] ✓ AI transitions active');
                                                    setupTransitionsUI();
                                                } else {
                                                    console.error('[AI Transitions] Failed to enable');
                                                }
                                            }
                                        } else {
                                            console.error('[AI Transitions] Class not found');
                                        }

                                        // Register and enable State Manager
                                        if (window.NeuralStateManager) {
                                            console.log('[State Manager] Registering...');
                                            const stateRegistered = window.NeuralBridge.registerInnovation('State Manager', window.NeuralStateManager);

                                            if (stateRegistered) {
                                                console.log('[State Manager] Enabling...');
                                                const stateEnabled = await window.NeuralBridge.enableInnovation('State Manager');

                                                if (stateEnabled) {
                                                    console.log('[State Manager] ✓ State persistence active');
                                                    setupStateManagerUI();
                                                } else {
                                                    console.error('[State Manager] Failed to enable');
                                                }
                                            }
                                        } else {
                                            console.error('[State Manager] Class not found');
                                        }

                                        // Register and enable Track Loader
                                        if (window.NeuralTrackLoader) {
                                            console.log('[Track Loader] Registering...');
                                            const loaderInstance = new window.NeuralTrackLoader(window.NeuralBridge.eventBus);
                                            const loaderRegistered = window.NeuralBridge.registerInnovation('Track Loader', loaderInstance);

                                            if (loaderRegistered) {
                                                console.log('[Track Loader] Enabling...');
                                                const loaderEnabled = await window.NeuralBridge.enableInnovation('Track Loader');

                                                if (loaderEnabled) {
                                                    console.log('[Track Loader] ✓ Auto-loading system ready');

                                                    // Register and enable Prophetic Loader
                                                    if (window.NeuralPropheticLoader) {
                                                        console.log('[Prophetic Loader] Registering...');
                                                        const propheticRegistered = window.NeuralBridge.registerInnovation('Prophetic Loader', window.NeuralPropheticLoader);

                                                        if (propheticRegistered) {
                                                            console.log('[Prophetic Loader] Enabling...');
                                                            const propheticEnabled = await window.NeuralBridge.enableInnovation('Prophetic Loader');

                                                            if (propheticEnabled) {
                                                                // Link Prophetic Loader to Track Loader
                                                                loaderInstance.setPropheticLoader(window.NeuralPropheticLoader);
                                                                console.log('[Prophetic Loader] ✓ Mystical playlist system ready 🔮');
                                                            } else {
                                                                console.error('[Prophetic Loader] Failed to enable');
                                                            }
                                                        }
                                                    } else {
                                                        console.warn('[Prophetic Loader] Class not found');
                                                    }
                                                } else {
                                                    console.error('[Track Loader] Failed to enable');
                                                }
                                            }
                                        } else {
                                            console.warn('[Track Loader] Class not found - auto-loading disabled');
                                        }

                                        // Register and enable Narrative Engine
                                        if (window.NeuralNarrativeEngine) {
                                            console.log('[Narrative Engine] Registering...');
                                            const narrativeRegistered = window.NeuralBridge.registerInnovation('Narrative Engine', window.NeuralNarrativeEngine);

                                            if (narrativeRegistered) {
                                                console.log('[Narrative Engine] Enabling...');
                                                const narrativeEnabled = await window.NeuralBridge.enableInnovation('Narrative Engine');

                                                if (narrativeEnabled) {
                                                    console.log('[Narrative Engine] ✓ Story system ready 📖');
                                                } else {
                                                    console.error('[Narrative Engine] Failed to enable');
                                                }
                                            }
                                        } else {
                                            console.warn('[Narrative Engine] Class not found');
                                        }

                                        // Register and enable Web3 Connector
                                        if (window.NeuralWeb3Connector) {
                                            console.log('[Web3 Connector] Registering...');
                                            const web3Registered = window.NeuralBridge.registerInnovation('Web3 Connector', window.NeuralWeb3Connector);

                                            if (web3Registered) {
                                                console.log('[Web3 Connector] Enabling...');
                                                const web3Enabled = await window.NeuralBridge.enableInnovation('Web3 Connector');

                                                if (web3Enabled) {
                                                    console.log('[Web3 Connector] ✓ Blockchain bridge ready 🔗');

                                                    // Register and enable DAO Curator
                                                    if (window.NeuralDAOCurator) {
                                                        console.log('[DAO Curator] Registering...');
                                                        const daoRegistered = window.NeuralBridge.registerInnovation('DAO Curator', window.NeuralDAOCurator);

                                                        if (daoRegistered) {
                                                            const daoEnabled = await window.NeuralBridge.enableInnovation('DAO Curator');
                                                            if (daoEnabled) {
                                                                console.log('[DAO Curator] ✓ Ritual voting ready 🗳️');
                                                            }
                                                        }
                                                    }

                                                    // Register and enable NFT Session
                                                    if (window.NeuralNFTSession) {
                                                        console.log('[NFT Session] Registering...');
                                                        const nftRegistered = window.NeuralBridge.registerInnovation('NFT Session', window.NeuralNFTSession);

                                                        if (nftRegistered) {
                                                            const nftEnabled = await window.NeuralBridge.enableInnovation('NFT Session');
                                                            if (nftEnabled) {
                                                                console.log('[NFT Session] ✓ Session minting ready 🎨');
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            console.warn('[Web3 Connector] Class not found - blockchain features disabled');
                                        }

                                        // Register and enable AI Autopilot
                                        if (window.NeuralAIAutopilot) {
                                            console.log('[AI Autopilot] Registering...');
                                            const autopilotRegistered = window.NeuralBridge.registerInnovation('AI Autopilot', window.NeuralAIAutopilot);

                                            if (autopilotRegistered) {
                                                console.log('[AI Autopilot] Enabling...');
                                                const autopilotEnabled = await window.NeuralBridge.enableInnovation('AI Autopilot');

                                                if (autopilotEnabled) {
                                                    console.log('[AI Autopilot] ✓ DJ Cloudio Autopilot ready');
                                                    setupAutopilotUI();
                                                } else {
                                                    console.error('[AI Autopilot] Failed to enable');
                                                }
                                            }
                                        } else {
                                            console.error('[AI Autopilot] Class not found');
                                        }
                                    } else {
                                        console.error('[AI Module] Failed to enable');
                                    }
                                }
                            } else {
                                console.error('[AI Module] Class not found');
                            }
                        } else {
                            console.error('[Neural Audio Bridge] Initialization failed');
                        }
                    } else {
                        if (!window.NeuralAudioBridge) console.error('[Neural Audio Bridge] Class not found');
                        if (!window.app.audioContext) console.error('[Neural Audio Bridge] AudioContext not found');
                    }
                } else {
                    console.error('[Neural Bridge] Initialization failed - check validation requirements');
                }
            }, 500);
        });

        // Setup AI event listeners
        function setupAIEventListeners() {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) return;

            // Listen for analysis complete events
            eventBus.on('ai:analysis:complete', (data) => {
                const { deckId, analysis } = data;
                console.log(`[AI UI] Analysis complete for deck ${deckId}:`, analysis);

                // Update UI
                updateAIPanel(deckId, analysis);
            });

            // Listen for mixing suggestions
            eventBus.on('ai:suggestions', (suggestions) => {
                console.log('[AI UI] Suggestions received:', suggestions);
                updateSuggestionsPanel(suggestions);
            });

            console.log('[AI UI] Event listeners registered');
        }

        // Update AI analysis panel
        function updateAIPanel(deckId, analysis) {
            const panel = document.getElementById(`ai-panel-${deckId}`);
            if (!panel) return;

            // Show panel
            panel.style.display = 'block';

            // Update BPM
            document.getElementById(`ai-bpm-${deckId}`).textContent = analysis.bpm.value;
            document.getElementById(`ai-bpm-conf-${deckId}`).textContent =
                `(${Math.round(analysis.bpm.confidence * 100)}%)`;

            // Update Key
            document.getElementById(`ai-key-${deckId}`).textContent = analysis.key.value;
            document.getElementById(`ai-key-conf-${deckId}`).textContent =
                `(${Math.round(analysis.key.confidence * 100)}%)`;

            // Update Genre
            document.getElementById(`ai-genre-${deckId}`).textContent =
                `${analysis.genre.value} (${Math.round(analysis.genre.confidence * 100)}%)`;

            // Update Energy
            const energyValue = Math.round(analysis.energy.value * 100);
            document.getElementById(`ai-energy-${deckId}`).textContent =
                `${analysis.energy.level.toUpperCase()} (${energyValue}%)`;
        }

        // Update suggestions panel
        function updateSuggestionsPanel(suggestions) {
            const panel = document.getElementById('ai-suggestions-panel');
            const content = document.getElementById('ai-suggestions-content');

            if (!panel || !content) return;

            // Clear previous suggestions
            content.innerHTML = '';

            // Show panel
            panel.style.display = 'block';

            // Add compatibility status
            const compatibilityDiv = document.createElement('div');
            compatibilityDiv.className = `ai-suggestion ${suggestions.compatible ? '' : 'warning'}`;
            compatibilityDiv.textContent = suggestions.compatible
                ? '✅ Tracks are compatible for mixing'
                : '⚠️ Tracks may not mix well together';
            content.appendChild(compatibilityDiv);

            // Add recommendations
            suggestions.recommendations.forEach(rec => {
                const suggestionDiv = document.createElement('div');

                // Determine class based on action
                let className = 'ai-suggestion';
                if (rec.action === 'skip') className += ' error';
                else if (rec.action === 'adjust_tempo') className += ' warning';

                suggestionDiv.className = className;
                suggestionDiv.textContent = `${rec.type.toUpperCase()}: ${rec.message}`;

                content.appendChild(suggestionDiv);
            });
        }

        // Setup AI Transitions UI
        function setupTransitionsUI() {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) return;

            // Show transitions panel
            const panel = document.getElementById('ai-transitions-panel');
            if (panel) {
                panel.style.display = 'block';
            }

            // Listen for transition events
            eventBus.on('transition:started', (transition) => {
                console.log('[Transitions UI] Transition started:', transition);
                showTransitionProgress();
            });

            eventBus.on('transition:progress', (data) => {
                updateTransitionProgress(data.progress);
            });

            eventBus.on('transition:completed', (transition) => {
                console.log('[Transitions UI] Transition completed:', transition);
                hideTransitionProgress();
            });

            eventBus.on('transition:planned', (plan) => {
                console.log('[Transitions UI] Transition planned:', plan);
                // Could show visual indicator of planned transition
            });

            console.log('[Transitions UI] Event listeners registered');
        }

        // Switch transition tab
        function switchTransitionTab(tabName) {
            // Hide all transition panels
            document.getElementById('classic-transitions').style.display = 'none';
            document.getElementById('advanced-transitions').style.display = 'none';
            document.getElementById('ritual-transitions').style.display = 'none';

            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected panel and activate tab
            document.getElementById(`${tabName}-transitions`).style.display = 'grid';
            event.target.classList.add('active');

            console.log(`[Transitions UI] Switched to ${tabName} tab`);
        }

        // Trigger ritual preset
        function triggerRitual(ritualName) {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) {
                console.error('[Transitions UI] Event bus not available');
                return;
            }

            console.log(`[Transitions UI] Triggering ritual: ${ritualName}`);

            // Emit ritual trigger event
            eventBus.emit('ritual:trigger', {
                ritual: ritualName,
                fromDeck: 'a',
                toDeck: 'b',
                duration: 18000, // 18 seconds for rituals (longer than normal)
                source: 'manual'
            });

            // Visual feedback
            event.target.style.transform = 'scale(0.95)';
            setTimeout(() => {
                event.target.style.transform = '';
            }, 200);
        }

        // Trigger AI transition
        function triggerAITransition(type) {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) {
                console.error('[Transitions UI] Event bus not available');
                return;
            }

            console.log(`[Transitions UI] Triggering ${type} transition`);

            // Emit transition trigger event
            eventBus.emit('transition:trigger', {
                type: type,
                fromDeck: 'a',
                toDeck: 'b',
                duration: 12000 // 12 seconds default
            });
        }

        // Show transition progress
        function showTransitionProgress() {
            const progressEl = document.getElementById('transition-progress');
            if (progressEl) {
                progressEl.style.display = 'block';
                updateTransitionProgress(0);
            }
        }

        // Update transition progress
        function updateTransitionProgress(progress) {
            const fillEl = document.getElementById('progress-fill');
            const infoEl = document.getElementById('progress-info');

            if (fillEl) {
                fillEl.style.width = `${progress * 100}%`;
            }

            if (infoEl) {
                infoEl.textContent = `${Math.round(progress * 100)}%`;
            }
        }

        // Hide transition progress
        function hideTransitionProgress() {
            const progressEl = document.getElementById('transition-progress');
            if (progressEl) {
                setTimeout(() => {
                    progressEl.style.display = 'none';
                }, 1000);
            }
        }

        // Setup State Manager UI
        function setupStateManagerUI() {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) return;

            // Show state manager panel
            const panel = document.getElementById('state-manager-panel');
            if (panel) {
                panel.style.display = 'block';
            }

            // Listen for state events
            eventBus.on('state:session-loaded', (session) => {
                updateSessionInfo(session);
            });

            eventBus.on('state:auto-saved', (data) => {
                updateLastSavedTime();
            });

            // Get innovation instance
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (stateManager && stateManager.currentSession) {
                updateSessionInfo(stateManager.currentSession);
            }

            console.log('[State Manager UI] Event listeners registered');
        }

        // Update session info display
        function updateSessionInfo(session) {
            const nameEl = document.getElementById('current-session-name');
            if (nameEl && session) {
                nameEl.textContent = session.name || `Session #${session.id}`;
            }
            updateLastSavedTime();
        }

        // Update last saved time
        function updateLastSavedTime() {
            const timeEl = document.getElementById('last-saved-time');
            if (timeEl) {
                const now = new Date();
                timeEl.textContent = now.toLocaleTimeString();
            }
        }

        // Create new session
        async function createNewSession() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager) return;

            const name = prompt('Enter session name:', 'New Session');
            if (!name) return;

            try {
                const session = await stateManager.createSession(name);
                stateManager.currentSession = session;
                updateSessionInfo(session);
                console.log('[State Manager UI] New session created:', session.id);
                alert(`Session "${name}" created successfully!`);
            } catch (error) {
                console.error('[State Manager UI] Failed to create session:', error);
                alert('Failed to create session: ' + error.message);
            }
        }

        // Save current session
        async function saveCurrentSession() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager?.currentSession) {
                alert('No active session to save');
                return;
            }

            try {
                await stateManager.saveSession(stateManager.currentSession);
                updateLastSavedTime();
                console.log('[State Manager UI] Session saved');
                alert('Session saved successfully!');
            } catch (error) {
                console.error('[State Manager UI] Failed to save session:', error);
                alert('Failed to save session: ' + error.message);
            }
        }

        // Create snapshot
        async function createSessionSnapshot() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager?.currentSession) {
                alert('No active session');
                return;
            }

            const label = prompt('Enter snapshot label:', 'Quick Save');
            if (!label) return;

            try {
                const snapshotId = await stateManager.createSnapshot(label);
                console.log('[State Manager UI] Snapshot created:', snapshotId);
                alert(`Snapshot "${label}" created successfully!`);
            } catch (error) {
                console.error('[State Manager UI] Failed to create snapshot:', error);
                alert('Failed to create snapshot: ' + error.message);
            }
        }

        // Show session history
        async function showSessionHistory() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager?.currentSession) {
                alert('No active session');
                return;
            }

            try {
                const history = await stateManager.getSessionHistory(20);
                console.log('[State Manager UI] Session history:', history);

                // Display in console for now
                if (history.length === 0) {
                    alert('No history for this session');
                } else {
                    let message = `Session History (${history.length} entries):\n\n`;
                    history.slice(0, 10).forEach(entry => {
                        const time = new Date(entry.timestamp).toLocaleTimeString();
                        message += `[${time}] ${entry.type}\n`;
                    });
                    alert(message);
                }
            } catch (error) {
                console.error('[State Manager UI] Failed to get history:', error);
                alert('Failed to load history: ' + error.message);
            }
        }

        // Export session
        async function exportCurrentSession() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager?.currentSession) {
                alert('No active session to export');
                return;
            }

            try {
                const data = await stateManager.exportSession(stateManager.currentSession.id);

                // Create download
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `session-${stateManager.currentSession.id}-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                console.log('[State Manager UI] Session exported');
                alert('Session exported successfully!');
            } catch (error) {
                console.error('[State Manager UI] Failed to export session:', error);
                alert('Failed to export session: ' + error.message);
            }
        }

        // Import session
        async function importSession() {
            const stateManager = window.NeuralBridge.innovations.get('State Manager')?.instance;
            if (!stateManager) return;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    const sessionId = await stateManager.importSession(data);
                    console.log('[State Manager UI] Session imported:', sessionId);
                    alert(`Session imported successfully! ID: ${sessionId}`);
                } catch (error) {
                    console.error('[State Manager UI] Failed to import session:', error);
                    alert('Failed to import session: ' + error.message);
                }
            };

            input.click();
        }

        // Hide session list
        function hideSessionList() {
            const container = document.getElementById('session-list-container');
            if (container) {
                container.style.display = 'none';
            }
        }

        // === WEB3 UI FUNCTIONS ===

        // Toggle Web3 panel
        function toggleWeb3Panel() {
            const web3Panel = document.getElementById('web3-panel');
            const otherPanels = [
                document.getElementById('autopilot-panel'),
                document.getElementById('narrative-panel'),
                document.getElementById('prophetic-panel'),
                document.getElementById('state-panel'),
                document.getElementById('loader-panel')
            ];

            // Hide other panels
            otherPanels.forEach(panel => {
                if (panel) panel.style.display = 'none';
            });

            // Toggle Web3 panel
            if (web3Panel) {
                web3Panel.style.display = web3Panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Connect Web3 Wallet
        async function connectWeb3Wallet() {
            const connector = window.NeuralWeb3Connector;
            if (!connector) {
                alert('Web3 Connector not initialized. Please refresh the page.');
                return;
            }

            try {
                const walletInfo = await connector.connectWallet();

                // Update UI
                const walletSection = document.querySelector('.wallet-section');
                if (walletSection) {
                    walletSection.innerHTML = `
                        <div class="wallet-info">
                            <div class="wallet-address">
                                <strong>Wallet:</strong> ${walletInfo.account.slice(0, 6)}...${walletInfo.account.slice(-4)}
                            </div>
                            <div class="wallet-network">
                                <strong>Network:</strong> ${connector.chains[walletInfo.chainId]?.name || 'Unknown'}
                            </div>
                            <div class="wallet-balance">
                                <strong>Balance:</strong> ${walletInfo.balance} ${connector.chains[walletInfo.chainId]?.symbol || 'ETH'}
                            </div>
                            <button class="btn-web3 btn-disconnect" onclick="disconnectWeb3Wallet()">
                                🔌 DISCONNECT
                            </button>
                        </div>
                    `;
                }

                // Show DAO and NFT sections
                const daoSection = document.getElementById('dao-section');
                const nftSection = document.getElementById('nft-section');
                if (daoSection) daoSection.style.display = 'block';
                if (nftSection) nftSection.style.display = 'block';

                console.log('[Web3 UI] Wallet connected:', walletInfo);
            } catch (error) {
                console.error('[Web3 UI] Failed to connect wallet:', error);
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        // Disconnect Web3 Wallet
        function disconnectWeb3Wallet() {
            const connector = window.NeuralWeb3Connector;
            if (!connector) return;

            connector.disconnect();

            // Reset UI
            const walletSection = document.querySelector('.wallet-section');
            if (walletSection) {
                walletSection.innerHTML = `
                    <button class="btn-web3 btn-connect" onclick="connectWeb3Wallet()">
                        🔌 CONNECT WALLET
                    </button>
                `;
            }

            // Hide DAO and NFT sections
            const daoSection = document.getElementById('dao-section');
            const nftSection = document.getElementById('nft-section');
            if (daoSection) daoSection.style.display = 'none';
            if (nftSection) nftSection.style.display = 'none';

            console.log('[Web3 UI] Wallet disconnected');
        }

        // Create DAO Proposal
        async function createDAOProposal() {
            const daoCurator = window.NeuralDAOCurator;
            if (!daoCurator) {
                alert('DAO Curator not initialized. Please refresh the page.');
                return;
            }

            const connector = window.NeuralWeb3Connector;
            if (!connector?.connected) {
                alert('Please connect your wallet first.');
                return;
            }

            // Get event info from user
            const eventName = prompt('Event Name:', 'DJ Cloudio Session');
            if (!eventName) return;

            const eventDate = new Date(Date.now() + 86400000); // Tomorrow
            const votingDuration = 3600000; // 1 hour

            try {
                const proposal = await daoCurator.createRitualProposal({
                    name: eventName,
                    date: eventDate,
                    votingDuration: votingDuration
                });

                // Update DAO UI
                updateDAOProposals();

                console.log('[Web3 UI] Proposal created:', proposal);
                alert(`Proposal created!\nID: ${proposal.id}\nVoting ends in 1 hour`);
            } catch (error) {
                console.error('[Web3 UI] Failed to create proposal:', error);
                alert('Failed to create proposal: ' + error.message);
            }
        }

        // Update DAO proposals list
        function updateDAOProposals() {
            const daoCurator = window.NeuralDAOCurator;
            if (!daoCurator) return;

            const daoSection = document.getElementById('dao-section');
            if (!daoSection) return;

            const activeProposal = daoCurator.activeProposal ?
                daoCurator.proposals.get(daoCurator.activeProposal) : null;

            if (activeProposal) {
                const endTime = new Date(activeProposal.endTime).toLocaleString();
                const votesList = Array.from(activeProposal.votes.values())
                    .map(v => `<li>${v.ritualId} (${v.power} power) - ${v.reason || 'No reason'}</li>`)
                    .join('');

                const proposalHTML = `
                    <div class="section-title">🗳️ DAO RITUAL VOTING</div>
                    <button class="btn-web3 btn-create-proposal" onclick="createDAOProposal()">
                        + CREATE PROPOSAL
                    </button>
                    <div class="proposal-card">
                        <div><strong>${activeProposal.eventName}</strong></div>
                        <div>Ends: ${endTime}</div>
                        <div>Total Votes: ${activeProposal.totalVotingPower}</div>
                        <div class="ritual-options">
                            ${daoCurator.ritualOptions.map(opt => `
                                <button class="btn-ritual" onclick="castDAOVote('${activeProposal.id}', '${opt.id}')">
                                    ${opt.symbol} ${opt.name}
                                </button>
                            `).join('')}
                        </div>
                        ${votesList ? `<div class="votes-list"><strong>Votes:</strong><ul>${votesList}</ul></div>` : ''}
                        <button class="btn-web3 btn-finalize" onclick="finalizeDAOProposal('${activeProposal.id}')">
                            ✅ FINALIZE PROPOSAL
                        </button>
                    </div>
                `;

                daoSection.innerHTML = proposalHTML;
            }
        }

        // Cast DAO Vote
        async function castDAOVote(proposalId, ritualId) {
            const daoCurator = window.NeuralDAOCurator;
            if (!daoCurator) return;

            const reason = prompt(`Why vote for ${ritualId}?`, 'Perfect energy for the journey');
            if (reason === null) return;

            try {
                const vote = await daoCurator.castVote(proposalId, ritualId, reason);
                updateDAOProposals();
                console.log('[Web3 UI] Vote cast:', vote);
                alert('Vote submitted successfully!');
            } catch (error) {
                console.error('[Web3 UI] Failed to cast vote:', error);
                alert('Failed to cast vote: ' + error.message);
            }
        }

        // Finalize DAO Proposal
        async function finalizeDAOProposal(proposalId) {
            const daoCurator = window.NeuralDAOCurator;
            if (!daoCurator) return;

            try {
                const result = await daoCurator.finalizeProposal(proposalId);
                updateDAOProposals();
                console.log('[Web3 UI] Proposal finalized:', result);
                alert(`Proposal finalized!\nWinner: ${result.winner.symbol} ${result.winner.name}\nTotal votes: ${result.totalVotes}`);
            } catch (error) {
                console.error('[Web3 UI] Failed to finalize proposal:', error);
                alert('Failed to finalize proposal: ' + error.message);
            }
        }

        // Mint Current Session as NFT
        async function mintCurrentSession() {
            const nftSession = window.NeuralNFTSession;
            if (!nftSession) {
                alert('NFT Session module not initialized. Please refresh the page.');
                return;
            }

            const connector = window.NeuralWeb3Connector;
            if (!connector?.connected) {
                alert('Please connect your wallet first.');
                return;
            }

            if (!nftSession.currentSession) {
                alert('No active session to mint. Start autopilot and play some tracks first.');
                return;
            }

            const sessionId = nftSession.currentSession.id;
            const recipient = connector.account;

            try {
                const result = await nftSession.mintSessionNFT(sessionId, recipient);

                // Update NFT UI
                updateNFTSessions();

                console.log('[Web3 UI] NFT minted:', result);
                alert(`Session NFT minted!\nTx: ${result.txHash}\nIPFS: ${result.ipfsUrl}`);
            } catch (error) {
                console.error('[Web3 UI] Failed to mint NFT:', error);
                alert('Failed to mint NFT: ' + error.message);
            }
        }

        // Update NFT Sessions List
        function updateNFTSessions() {
            const nftSession = window.NeuralNFTSession;
            if (!nftSession) return;

            const nftSection = document.getElementById('nft-section');
            if (!nftSection) return;

            const sessions = nftSession.sessionHistory.slice(0, 5); // Last 5 sessions

            const sessionsHTML = sessions.map(s => {
                const duration = Math.floor((s.endTime - s.startTime) / 60000);
                return `
                    <div class="session-card">
                        <div><strong>${s.djName}</strong></div>
                        <div>${duration} min | ${s.stats.totalTracks} tracks | ${s.stats.totalRituals} rituals</div>
                        <div>Story: ${s.story || 'Freestyle'}</div>
                        ${s.mintedNFT ?
                            `<div class="nft-minted">✅ NFT Minted</div>` :
                            `<button class="btn-web3 btn-mint" onclick="mintSessionById('${s.id}')">Mint NFT</button>`
                        }
                    </div>
                `;
            }).join('');

            nftSection.innerHTML = `
                <div class="section-title">🎨 MINT SESSION NFT</div>
                <button class="btn-web3 btn-mint" onclick="mintCurrentSession()">
                    Mint Current Session
                </button>
                ${sessionsHTML ? `<div class="sessions-list"><strong>Recent Sessions:</strong>${sessionsHTML}</div>` : ''}
            `;
        }

        // Mint Session by ID
        async function mintSessionById(sessionId) {
            const nftSession = window.NeuralNFTSession;
            const connector = window.NeuralWeb3Connector;

            if (!connector?.connected) {
                alert('Please connect your wallet first.');
                return;
            }

            try {
                const result = await nftSession.mintSessionNFT(sessionId, connector.account);
                updateNFTSessions();
                alert(`Session NFT minted!\nTx: ${result.txHash}`);
            } catch (error) {
                alert('Failed to mint NFT: ' + error.message);
            }
        }

        // Setup Web3 Event Listeners
        function setupWeb3EventListeners() {
            const eventBus = window.NeuralEventBus;
            if (!eventBus) return;

            // Web3 connection events
            eventBus.on('web3:connected', (data) => {
                console.log('[Web3 UI] Connected:', data);
                updateDAOProposals();
                updateNFTSessions();
            });

            eventBus.on('web3:disconnected', () => {
                console.log('[Web3 UI] Disconnected');
            });

            // DAO events
            eventBus.on('dao:proposal-created', (data) => {
                console.log('[Web3 UI] Proposal created:', data);
                updateDAOProposals();
            });

            eventBus.on('dao:vote-submitted', (data) => {
                console.log('[Web3 UI] Vote submitted:', data);
            });

            eventBus.on('dao:proposal-finalized', (data) => {
                console.log('[Web3 UI] Proposal finalized:', data);
            });

            // NFT events
            eventBus.on('nft:session-started', (data) => {
                console.log('[Web3 UI] Session recording started:', data);
            });

            eventBus.on('nft:session-ended', (data) => {
                console.log('[Web3 UI] Session recording ended:', data);
                updateNFTSessions();
            });

            eventBus.on('nft:minted', (data) => {
                console.log('[Web3 UI] NFT minted:', data);
            });
        }

        // === AI AUTOPILOT UI FUNCTIONS ===

        function setupAutopilotUI() {
            const panel = document.getElementById('autopilot-panel');
            if (panel) {
                panel.style.display = 'block';
            }

            // Listen for autopilot events
            const autopilot = window.NeuralAIAutopilot;
            if (autopilot && autopilot.eventBus) {
                // Update UI when autopilot starts
                autopilot.eventBus.on('autopilot:started', () => {
                    document.getElementById('autopilot-status').textContent = 'ACTIVE';
                    document.getElementById('autopilot-status').style.color = '#4ade80';
                    document.getElementById('autopilot-start-btn').style.display = 'none';
                    document.getElementById('autopilot-stop-btn').style.display = 'block';
                });

                // Update UI when autopilot stops
                autopilot.eventBus.on('autopilot:stopped', () => {
                    document.getElementById('autopilot-status').textContent = 'INACTIVE';
                    document.getElementById('autopilot-status').style.color = '#a855f7';
                    document.getElementById('autopilot-start-btn').style.display = 'block';
                    document.getElementById('autopilot-stop-btn').style.display = 'none';
                    document.getElementById('autopilot-countdown').textContent = '--:--';
                });

                // Update stats
                autopilot.eventBus.on('autopilot:stats:update', (stats) => {
                    updateAutopilotStats(stats);
                });

                // Update countdown
                autopilot.eventBus.on('autopilot:countdown:update', (data) => {
                    const minutes = Math.floor(data.remaining / 60000);
                    const seconds = Math.floor((data.remaining % 60000) / 1000);
                    document.getElementById('autopilot-countdown').textContent =
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                });

                // Show track suggestion
                autopilot.eventBus.on('autopilot:track:suggestion', (suggestion) => {
                    showTrackSuggestion(suggestion);
                });

                console.log('[Autopilot UI] Event listeners registered');
            }
        }

        function startAutopilot() {
            const autopilot = window.NeuralAIAutopilot;
            if (autopilot && autopilot.start) {
                autopilot.start();
                console.log('[Autopilot UI] DJ Cloudio started');
            } else {
                console.error('[Autopilot UI] Autopilot not available or start method missing');
            }
        }

        function stopAutopilot() {
            const autopilot = window.NeuralAIAutopilot;
            if (autopilot && autopilot.stop) {
                autopilot.stop();
                console.log('[Autopilot UI] DJ Cloudio stopped');
            }
        }

        function updateEnergyStrategy() {
            const select = document.getElementById('energy-strategy');
            const strategy = select.value;
            const autopilot = window.NeuralAIAutopilot;

            if (autopilot && autopilot.config) {
                autopilot.config.energyFlowStrategy = strategy;
                document.getElementById('autopilot-energy').textContent = strategy.toUpperCase();
                console.log(`[Autopilot UI] Energy strategy: ${strategy}`);
            }
        }

        function updateTransitionTiming() {
            const select = document.getElementById('transition-timing');
            const timing = select.value;
            const autopilot = window.NeuralAIAutopilot;

            if (autopilot && autopilot.config) {
                autopilot.config.transitionTiming = timing;
                console.log(`[Autopilot UI] Transition timing: ${timing}`);
            }
        }

        // Load track library for auto-loading
        async function loadTrackLibrary() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = 'audio/*';

            input.onchange = async (e) => {
                const files = Array.from(e.target.files);

                if (files.length === 0) {
                    console.log('[Track Loader UI] No files selected');
                    return;
                }

                console.log(`[Track Loader UI] Loading ${files.length} tracks...`);

                const trackLoader = window.NeuralBridge?.innovations?.get('Track Loader')?.instance;
                if (!trackLoader) {
                    console.error('[Track Loader UI] Track Loader not available');
                    alert('Track Loader not initialized. Please refresh the page.');
                    return;
                }

                // Initialize with library
                const success = await trackLoader.init(files);

                if (success) {
                    // Enable auto-loading
                    trackLoader.setAutoLoad(true);

                    // Update UI
                    const statusEl = document.getElementById('loader-status');
                    if (statusEl) {
                        statusEl.textContent = `${files.length} tracks loaded`;
                        statusEl.style.color = '#10b981';
                    }

                    console.log(`[Track Loader UI] ✓ Library loaded: ${files.length} tracks`);
                    console.log('[Track Loader UI] ✓ Auto-loading enabled');
                } else {
                    alert('Failed to load track library');
                }
            };

            input.click();
        }

        // Preload specific tracks into queues
        function preloadQueues() {
            const trackLoader = window.NeuralBridge?.innovations?.get('Track Loader')?.instance;
            if (!trackLoader) {
                alert('Track Loader not initialized. Load a library first.');
                return;
            }

            if (!trackLoader.library || trackLoader.library.length === 0) {
                alert('No tracks in library. Load a library first.');
                return;
            }

            // Create modal for track selection
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(145deg, #1f2937, #111827);
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 10000;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;

            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 9999;
            `;

            modal.innerHTML = `
                <h3 style="color: #10b981; margin: 0 0 16px 0; font-size: 1.1rem;">🎯 Preload Track Queues</h3>

                <div style="margin-bottom: 20px;">
                    <label style="color: #d1d5db; font-size: 0.85rem; display: block; margin-bottom: 8px;">
                        Deck A Queue (${trackLoader.library.length} tracks available):
                    </label>
                    <select id="preload-deck-a" multiple style="width: 100%; height: 120px; background: #374151; color: #f3f4f6; border: 1px solid #4b5563; border-radius: 6px; padding: 8px;">
                        ${trackLoader.library.map((track, i) => `
                            <option value="${i}">${track.name || `Track ${i + 1}`}</option>
                        `).join('')}
                    </select>
                    <small style="color: #9ca3af; display: block; margin-top: 4px;">Hold Ctrl/Cmd to select multiple</small>
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="color: #d1d5db; font-size: 0.85rem; display: block; margin-bottom: 8px;">
                        Deck B Queue:
                    </label>
                    <select id="preload-deck-b" multiple style="width: 100%; height: 120px; background: #374151; color: #f3f4f6; border: 1px solid #4b5563; border-radius: 6px; padding: 8px;">
                        ${trackLoader.library.map((track, i) => `
                            <option value="${i}">${track.name || `Track ${i + 1}`}</option>
                        `).join('')}
                    </select>
                    <small style="color: #9ca3af; display: block; margin-top: 4px;">Hold Ctrl/Cmd to select multiple</small>
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="preload-cancel" style="padding: 10px 20px; background: #374151; color: #f3f4f6; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        Cancel
                    </button>
                    <button id="preload-confirm" style="padding: 10px 20px; background: linear-gradient(145deg, #059669, #10b981); color: #d1fae5; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        Preload Queues
                    </button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(modal);

            // Cancel button
            document.getElementById('preload-cancel').onclick = () => {
                document.body.removeChild(modal);
                document.body.removeChild(overlay);
            };

            // Confirm button
            document.getElementById('preload-confirm').onclick = () => {
                const deckASelect = document.getElementById('preload-deck-a');
                const deckBSelect = document.getElementById('preload-deck-b');

                const deckAIndices = Array.from(deckASelect.selectedOptions).map(opt => parseInt(opt.value));
                const deckBIndices = Array.from(deckBSelect.selectedOptions).map(opt => parseInt(opt.value));

                const tracksA = deckAIndices.map(i => trackLoader.library[i]);
                const tracksB = deckBIndices.map(i => trackLoader.library[i]);

                trackLoader.preload(tracksA, tracksB);

                const statusEl = document.getElementById('loader-status');
                if (statusEl) {
                    statusEl.textContent = `A:${tracksA.length} | B:${tracksB.length} preloaded`;
                    statusEl.style.color = '#10b981';
                }

                console.log(`[Track Loader UI] ✓ Preloaded: A=${tracksA.length}, B=${tracksB.length}`);

                document.body.removeChild(modal);
                document.body.removeChild(overlay);
            };

            // Close on overlay click
            overlay.onclick = () => {
                document.body.removeChild(modal);
                document.body.removeChild(overlay);
            };
        }

        // Toggle narrative panel
        function toggleNarrativePanel() {
            const panel = document.getElementById('narrative-panel');
            const autopilotPanel = document.getElementById('autopilot-panel');

            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                if (autopilotPanel) autopilotPanel.style.display = 'none';
            } else {
                panel.style.display = 'none';
                if (autopilotPanel) autopilotPanel.style.display = 'block';
            }
        }

        // Start narrative story
        function startNarrativeStory() {
            const select = document.getElementById('story-select');
            const storyName = select.value;

            if (!storyName) {
                alert('Please select a story first');
                return;
            }

            const narrativeEngine = window.NeuralBridge?.innovations?.get('Narrative Engine')?.instance;
            if (!narrativeEngine) {
                alert('Narrative Engine not initialized');
                return;
            }

            const success = narrativeEngine.startStory(storyName);

            if (success) {
                // Show story UI elements
                document.getElementById('story-progress').style.display = 'block';
                document.getElementById('chapter-display').style.display = 'block';
                document.getElementById('end-story-btn').style.display = 'block';

                // Setup story event listeners
                setupNarrativeListeners();

                console.log(`[Narrative UI] Story started: ${storyName}`);
            }
        }

        // Setup narrative event listeners
        function setupNarrativeListeners() {
            const eventBus = window.NeuralBridge?.eventBus;
            if (!eventBus) return;

            // Listen for chapter changes
            eventBus.on('narrative:chapter-shown', (data) => {
                updateChapterDisplay(data);
            });

            // Listen for plot twists
            eventBus.on('narrative:plot-twist', (data) => {
                showPlotTwist(data);
            });

            // Listen for story progress
            eventBus.on('narrative:story-started', (data) => {
                document.getElementById('story-title').textContent = data.symbol + ' ' + data.story;
                document.getElementById('story-chapter-count').textContent = `1/${data.totalChapters}`;
            });

            console.log('[Narrative UI] Event listeners registered');
        }

        // Update chapter display
        function updateChapterDisplay(data) {
            document.getElementById('chapter-number').textContent = `Chapter ${data.index + 1}`;
            document.getElementById('chapter-title').textContent = data.chapter;
            document.getElementById('chapter-narrative').textContent = `"${data.narrative}"`;
            document.getElementById('chapter-ritual').textContent = `${data.ritual}`;
            document.getElementById('chapter-mood').textContent = `Mood: ${data.mood || 'mysterious'}`;

            // Update progress bar
            const narrativeEngine = window.NeuralBridge?.innovations?.get('Narrative Engine')?.instance;
            if (narrativeEngine) {
                const progress = narrativeEngine.storyProgress;
                document.getElementById('story-progress-fill').style.width = `${progress}%`;

                const currentChapter = narrativeEngine.currentChapter + 1;
                const totalChapters = narrativeEngine.activeStory?.totalChapters || 0;
                document.getElementById('story-chapter-count').textContent = `${currentChapter}/${totalChapters}`;
            }
        }

        // Show plot twist alert
        function showPlotTwist(data) {
            const alert = document.getElementById('plot-twist-alert');
            document.getElementById('twist-title').textContent = data.name.toUpperCase();
            document.getElementById('twist-effect').textContent = data.effect;

            alert.style.display = 'block';

            // Hide after 5 seconds
            setTimeout(() => {
                alert.style.display = 'none';
            }, 5000);

            console.log('[Narrative UI] 🌟 Plot twist displayed:', data.name);
        }

        // End narrative story
        function endNarrativeStory() {
            const narrativeEngine = window.NeuralBridge?.innovations?.get('Narrative Engine')?.instance;
            if (narrativeEngine) {
                narrativeEngine.endStory();
            }

            // Hide story UI elements
            document.getElementById('story-progress').style.display = 'none';
            document.getElementById('chapter-display').style.display = 'none';
            document.getElementById('plot-twist-alert').style.display = 'none';
            document.getElementById('end-story-btn').style.display = 'none';

            console.log('[Narrative UI] Story ended');
        }

        // Toggle prophetic mode
        function togglePropheticMode() {
            const checkbox = document.getElementById('prophetic-mode');
            const enabled = checkbox.checked;

            const trackLoader = window.NeuralBridge?.innovations?.get('Track Loader')?.instance;
            const propheticLoader = window.NeuralBridge?.innovations?.get('Prophetic Loader')?.instance;

            if (trackLoader && propheticLoader) {
                trackLoader.propheticMode = enabled;
                propheticLoader.setEnabled(enabled);

                console.log(`[Prophetic Mode] ${enabled ? 'Enabled' : 'Disabled'}`);

                if (enabled) {
                    console.log('[Prophetic Mode] 🔮 Tracks will be selected based on ritual energies and tarot card meanings');
                    console.log(`[Prophetic Mode] Available rituals: ${Object.keys(propheticLoader.ritualEnergies).join(', ')}`);
                    console.log(`[Prophetic Mode] Tarot deck: ${Object.keys(propheticLoader.tarotVibrations).length} cards`);
                }
            }
        }

        function updateAutopilotStats(stats) {
            document.getElementById('stat-transitions').textContent = stats.totalTransitions || 0;

            // Format duration
            const duration = stats.sessionDuration || 0;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            document.getElementById('stat-duration').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            // Average energy
            const avgEnergy = Math.round((stats.averageEnergy || 0) * 100);
            document.getElementById('stat-avg-energy').textContent = `${avgEnergy}%`;

            // Average BPM
            const avgBpm = Math.round(stats.averageBPM || 0);
            document.getElementById('stat-avg-bpm').textContent = avgBpm > 0 ? avgBpm : '---';
        }

        function showTrackSuggestion(suggestion) {
            const container = document.getElementById('track-suggestion');
            const content = document.getElementById('suggestion-content');

            if (suggestion && container && content) {
                let html = '<div style="font-size: 0.7rem;">';
                html += `<div style="margin-bottom: 4px;">🎵 <strong>BPM:</strong> ${suggestion.bpmRange[0]}-${suggestion.bpmRange[1]}</div>`;
                html += `<div style="margin-bottom: 4px;">⚡ <strong>Energy:</strong> ${suggestion.energy}</div>`;
                if (suggestion.key) {
                    html += `<div style="margin-bottom: 4px;">🎹 <strong>Key:</strong> ${suggestion.key}</div>`;
                }
                if (suggestion.genre) {
                    html += `<div>🎸 <strong>Genre:</strong> ${suggestion.genre}</div>`;
                }
                html += '</div>';

                content.innerHTML = html;
                container.style.display = 'block';
            }
        }
    </script>
    <script>
        // Additional script to ensure AI panels update and Web3 events
        document.addEventListener('DOMContentLoaded', () => {
            // Monitor for AI events after page load
            setTimeout(() => {
                if (window.NeuralBridge?.eventBus) {
                    console.log('[AI UI] Ready to display analysis');
                }

                // Setup Web3 event listeners
                setupWeb3EventListeners();
                console.log('[Web3 UI] Event listeners initialized');
            }, 1000);
        });
    </script>
</body>
</html>