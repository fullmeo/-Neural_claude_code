<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralMix P2P - Collaborative DJ Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0e2e 50%, #0c0c0c 100%);
            color: white;
            font-family: 'Monaco', 'Menlo', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(59, 130, 246, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(168, 85, 247, 0.3);
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .description {
            font-size: 0.9rem;
            color: #9ca3af;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .deck {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.8), rgba(55, 65, 81, 0.8));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(168, 85, 247, 0.3);
        }

        .deck-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #a855f7;
        }

        .deck-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .center-mixer {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9), rgba(75, 85, 99, 0.9));
            border: 1px solid rgba(236, 72, 153, 0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mixer-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .mixer-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 5px;
        }

        .file-upload {
            margin-bottom: 20px;
        }

        .file-upload input[type="file"] {
            width: 100%;
            padding: 10px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            color: white;
            font-family: monospace;
        }

        .waveform-container {
            height: 120px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .control-label {
            display: block;
            font-size: 0.8rem;
            font-weight: bold;
            color: #d1d5db;
            margin-bottom: 8px;
            text-align: center;
        }

        .control-slider {
            width: 100%;
            height: 40px;
            background: linear-gradient(to right, #374151, #6b7280);
            border-radius: 20px;
            position: relative;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .control-value {
            text-align: center;
            font-size: 0.8rem;
            color: #9ca3af;
            font-family: monospace;
        }

        .crossfader-section {
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 12px;
        }

        .crossfader-label {
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
            color: #ec4899;
            margin-bottom: 15px;
        }

        .crossfader {
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #a855f7, #ec4899, #22d3ee);
            border-radius: 30px;
            position: relative;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .crossfader-handle {
            position: absolute;
            top: 5px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: left 0.1s ease;
            cursor: grab;
        }

        .crossfader-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .play-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            font-size: 2rem;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
        }

        .play-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }

        .play-button.playing {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .p2p-section {
            background: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .p2p-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .p2p-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #22d3ee;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .connection-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input {
            flex: 1;
            padding: 8px 12px;
            background: rgba(55, 65, 81, 0.8);
            border: 1px solid rgba(107, 114, 128, 0.5);
            border-radius: 6px;
            color: white;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .input:focus {
            outline: none;
            border-color: #22d3ee;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #22d3ee, #06b6d4);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(34, 211, 238, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background: #22c55e; animation: pulse 2s infinite; }
        .status-connecting { background: #eab308; animation: pulse 1s infinite; }
        .status-disconnected { background: #6b7280; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .neural-section {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(236, 72, 153, 0.1));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .neural-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            margin-bottom: 15px;
        }

        .sync-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            text-align: center;
        }

        .sync-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .sync-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 5px;
        }

        .sync-label {
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .chat-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            height: 200px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .chat-message {
            font-size: 0.8rem;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 4px;
        }

        .chat-message.system { color: #9ca3af; }
        .chat-message.peer { color: #22d3ee; }
        .chat-message.local { color: #a855f7; }

        .spectral-display {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .spectral-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .spectral-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22d3ee;
            margin-bottom: 10px;
        }

        .spectral-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .signature {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            margin-top: 30px;
        }

        .signature-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #a855f7;
            margin-bottom: 8px;
        }

        .signature-author {
            color: #d1d5db;
            margin-bottom: 4px;
        }

        .signature-author span {
            color: #22d3ee;
            font-weight: bold;
        }

        .signature-quote {
            font-size: 0.9rem;
            color: #9ca3af;
            font-style: italic;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .connection-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="title">🎧 NeuralMix P2P</h1>
            <p class="subtitle">Collaborative Neural DJ Platform</p>
            <p class="description">Real-time P2P mixing with AI-powered beat sync and collaborative crossfading</p>
        </div>

        <!-- P2P Connection Section -->
        <div class="p2p-section">
            <div class="p2p-header">
                <span style="font-size: 1.5rem;">🌐</span>
                <h2 class="p2p-title">P2P Connection Hub</h2>
                <div id="connection-status">
                    <span class="status-indicator status-disconnected"></span>
                    <span id="status-text">Disconnected</span>
                </div>
            </div>
            
            <div class="connection-grid">
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Your DJ ID</h3>
                    <div class="input-group">
                        <input type="text" id="peer-id" class="input" readonly>
                        <button id="copy-id-btn" class="btn btn-primary">📋</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Share this ID with your mixing partner</p>
                </div>
                
                <div class="connection-panel">
                    <h3 style="color: #22d3ee; margin-bottom: 10px;">Connect to DJ</h3>
                    <div class="input-group">
                        <input type="text" id="remote-peer-id" class="input" placeholder="Enter DJ ID">
                        <button id="connect-btn" class="btn btn-success">🎵</button>
                    </div>
                    <p style="font-size: 0.8rem; color: #9ca3af; margin-top: 8px;">Join collaborative mix session</p>
                </div>
            </div>
        </div>

        <!-- Main Mixing Interface -->
        <div class="main-grid">
            <!-- Deck A -->
            <div class="deck">
                <div class="deck-header">
                    <h3 class="deck-title">DECK A</h3>
                    <span class="deck-status" id="deck-a-status">READY</span>
                </div>
                
                <div class="file-upload">
                    <input type="file" accept="audio/*" id="file-a" placeholder="Load Track A">
                </div>
                
                <div class="waveform-container">
                    <canvas id="waveform-a" class="waveform-canvas"></canvas>
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">VOLUME</label>
                        <div class="control-slider" data-deck="a" data-control="volume">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="volume-a-value">50%</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ HIGH</label>
                        <div class="control-slider" data-deck="a" data-control="high">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="high-a-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ MID</label>
                        <div class="control-slider" data-deck="a" data-control="mid">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="mid-a-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ LOW</label>
                        <div class="control-slider" data-deck="a" data-control="low">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="low-a-value">0dB</div>
                    </div>
                </div>
                
                <button class="play-button" id="play-a">▶</button>
            </div>

            <!-- Center Mixer -->
            <div class="center-mixer">
                <div class="mixer-header">
                    <h3 class="mixer-title">NEURAL MIXER</h3>
                    <p style="color: #9ca3af; font-size: 0.8rem;">AI-Powered Collaborative Mixing</p>
                </div>
                
                <div class="crossfader-section">
                    <div class="crossfader-label">COLLABORATIVE CROSSFADER</div>
                    <div class="crossfader" id="crossfader">
                        <div class="crossfader-handle" id="crossfader-handle" style="left: calc(50% - 25px);"></div>
                    </div>
                    <div class="crossfader-labels">
                        <span style="color: #a855f7;">DECK A</span>
                        <span style="color: #22d3ee;">DECK B</span>
                    </div>
                </div>
                
                <div class="neural-section">
                    <h3 class="neural-title">
                        <span>🧠</span>
                        Neural Sync Engine
                    </h3>
                    
                    <div class="sync-status">
                        <div class="sync-grid">
                            <div class="sync-item">
                                <div class="sync-value" id="bpm-sync">--</div>
                                <div class="sync-label">BPM SYNC</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="beat-align">--</div>
                                <div class="sync-label">BEAT ALIGN</div>
                            </div>
                            <div class="sync-item">
                                <div class="sync-value" id="neural-confidence">--</div>
                                <div class="sync-label">AI CONFIDENCE</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-section">
                        <div class="chat-messages" id="chat-messages">
                            <div class="chat-message system">🎵 NeuralMix P2P initialized</div>
                            <div class="chat-message system">🧠 Neural sync engine ready</div>
                        </div>
                        <div class="input-group">
                            <input type="text" id="chat-input" class="input" placeholder="Chat with DJ partner...">
                            <button id="send-chat-btn" class="btn btn-primary">📤</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Deck B -->
            <div class="deck">
                <div class="deck-header">
                    <h3 class="deck-title">DECK B</h3>
                    <span class="deck-status" id="deck-b-status">READY</span>
                </div>
                
                <div class="file-upload">
                    <input type="file" accept="audio/*" id="file-b" placeholder="Load Track B">
                </div>
                
                <div class="waveform-container">
                    <canvas id="waveform-b" class="waveform-canvas"></canvas>
                </div>
                
                <div class="controls-grid">
                    <div class="control-group">
                        <label class="control-label">VOLUME</label>
                        <div class="control-slider" data-deck="b" data-control="volume">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="volume-b-value">50%</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ HIGH</label>
                        <div class="control-slider" data-deck="b" data-control="high">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="high-b-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ MID</label>
                        <div class="control-slider" data-deck="b" data-control="mid">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="mid-b-value">0dB</div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">EQ LOW</label>
                        <div class="control-slider" data-deck="b" data-control="low">
                            <div class="slider-handle" style="left: 50%;"></div>
                        </div>
                        <div class="control-value" id="low-b-value">0dB</div>
                    </div>
                </div>
                
                <button class="play-button" id="play-b">▶</button>
            </div>
        </div>

        <!-- Spectral Analysis Display -->
        <div class="spectral-display">
            <div class="spectral-header">
                <h3 class="spectral-title">🌊 Real-Time Spectral Analysis</h3>
                <p style="color: #9ca3af;">Neural frequency analysis and collaborative mixing visualization</p>
            </div>
            <canvas id="spectral-canvas" class="spectral-canvas"></canvas>
        </div>

        <!-- Signature -->
        <div class="signature">
            <div class="signature-title">🎧 NeuralMix P2P Architecture</div>
            <div class="signature-author">
                Concepteur Système : <span>Serigne Diagne</span>
            </div>
            <div class="signature-quote">
                "Quand l'intelligence artificielle transforme le mixing en expérience collaborative"
            </div>
        </div>
    </div>

    <script>
        // Global State Management
        class NeuralMixState {
            constructor() {
                this.peerId = this.generatePeerId();
                this.remotePeerId = null;
                this.isConnected = false;
                this.audioContext = null;
                this.webRTC = null;
                this.dataChannel = null;
                
                this.decks = {
                    a: {
                        audio: null,
                        buffer: null,
                        source: null,
                        gainNode: null,
                        eqNodes: { high: null, mid: null, low: null },
                        analyser: null,
                        isPlaying: false,
                        bpm: null,
                        beatPhase: 0
                    },
                    b: {
                        audio: null,
                        buffer: null,
                        source: null,
                        gainNode: null,
                        eqNodes: { high: null, mid: null, low: null },
                        analyser: null,
                        isPlaying: false,
                        bpm: null,
                        beatPhase: 0
                    }
                };
                
                this.mixer = {
                    crossfaderPosition: 0.5,
                    masterVolume: 0.8
                };
                
                this.neural = {
                    beatSync: false,
                    confidence: 0,
                    syncOffset: 0
                };
            }

            generatePeerId() {
                return 'neuralmix-' + Math.random().toString(36).substr(2, 8);
            }
        }

        // Neural Beat Detection Engine
        class NeuralBeatDetector {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.detectionHistory = [];
                this.confidenceThreshold = 0.7;
            }

            detectBPM(analyserNode) {
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);
                
                // Analyse des fréquences basses pour détecter les kicks
                const bassFreqs = dataArray.slice(0, Math.floor(bufferLength * 0.1));
                const bassEnergy = bassFreqs.reduce((sum, val) => sum + val, 0) / bassFreqs.length;
                
                // Détection de pics d'énergie
                const now = this.audioContext.currentTime;
                if (bassEnergy > 120) { // Seuil de détection
                    this.detectionHistory.push(now);
                    
                    // Garder seulement les 10 dernières détections
                    if (this.detectionHistory.length > 10) {
                        this.detectionHistory = this.detectionHistory.slice(-10);
                    }
                    
                    // Calculer BPM basé sur les intervalles
                    if (this.detectionHistory.length >= 4) {
                        const intervals = [];
                        for (let i = 1; i < this.detectionHistory.length; i++) {
                            intervals.push(this.detectionHistory[i] - this.detectionHistory[i-1]);
                        }
                        
                        const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
                        const bpm = Math.round(60 / avgInterval);
                        
                        // Validation du BPM (plage réaliste)
                        if (bpm >= 80 && bpm <= 200) {
                            return { bpm, confidence: this.calculateConfidence(intervals) };
                        }
                    }
                }
                
                return null;
            }

            calculateConfidence(intervals) {
                if (intervals.length < 2) return 0;
                
                const mean = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
                const variance = intervals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / intervals.length;
                const stdDev = Math.sqrt(variance);
                
                // Confidence basée sur la consistance des intervalles
                const consistency = Math.max(0, 1 - (stdDev / mean));
                return Math.round(consistency * 100);
            }

            synchronizeDecks(deckA, deckB) {
                if (!deckA.bpm || !deckB.bpm) return null;
                
                const bpmDiff = Math.abs(deckA.bpm - deckB.bpm);
                const syncQuality = Math.max(0, 100 - (bpmDiff * 2));
                
                return {
                    syncQuality,
                    suggestedTempo: (deckA.bpm + deckB.bpm) / 2,
                    phaseOffset: (deckA.beatPhase - deckB.beatPhase) % 1
                };
            }
        }

        // Real P2P Connection Manager using WebSocket signaling
        class P2PConnectionManager {
            constructor(peerId, onMessage, onConnect, onDisconnect) {
                this.peerId = peerId;
                this.remotePeerId = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.onMessage = onMessage;
                this.onConnect = onConnect;
                this.onDisconnect = onDisconnect;
                this.websocket = null;
                this.connectionAttempts = 0;
                this.maxAttempts = 3;
                
                // Configuration WebRTC avec serveurs STUN publics
                this.config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };
                
                this.initializeSignaling();
            }

            initializeSignaling() {
                // Essayer plusieurs serveurs WebSocket publics
                const servers = [
                    'wss://ws.postman-echo.com/raw',
                    'wss://echo.websocket.org',
                    'wss://socketsbay.com/wss/v2/1/demo/',
                    'wss://demos.kaazing.com/echo'
                ];
                
                this.tryNextServer(servers, 0);
            }

            tryNextServer(servers, index) {
                if (index >= servers.length) {
                    console.log('🔧 All servers failed, enabling direct P2P mode');
                    this.enableDirectP2PMode();
                    return;
                }
                
                const serverUrl = servers[index];
                console.log(`🌐 Trying server ${index + 1}/${servers.length}: ${serverUrl}`);
                
                this.connectToSignalingServer(serverUrl, () => {
                    // Success callback
                    console.log(`✅ Connected to server ${index + 1}`);
                }, () => {
                    // Failure callback
                    console.log(`❌ Server ${index + 1} failed, trying next...`);
                    setTimeout(() => {
                        this.tryNextServer(servers, index + 1);
                    }, 1000);
                });
            }

            connectToSignalingServer(serverUrl, onSuccess, onFailure) {
                this.updateConnectionStatus('connecting');
                
                try {
                    this.websocket = new WebSocket(serverUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('🌐 Connected to signaling server');
                        this.updateConnectionStatus('signaling-connected');
                        
                        // S'enregistrer sur le serveur
                        this.sendSignalingMessage({
                            type: 'register',
                            peerId: this.peerId,
                            room: 'neuralmix'
                        });
                        
                        this.connectionAttempts = 0;
                        if (onSuccess) onSuccess();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleSignalingMessage(data);
                        } catch (e) {
                            // Peut-être un echo server, utiliser comme relay
                            this.handleEchoServerMessage(event.data);
                        }
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('🔌 Signaling server disconnected');
                        if (onFailure) onFailure();
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.log('🚨 Signaling error');
                        if (onFailure) onFailure();
                    };
                    
                    // Timeout après 5 secondes
                    setTimeout(() => {
                        if (this.websocket.readyState !== WebSocket.OPEN) {
                            this.websocket.close();
                            if (onFailure) onFailure();
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error('Failed to connect to signaling server:', error);
                    if (onFailure) onFailure();
                }
            }

            enableDirectP2PMode() {
                this.updateConnectionStatus('direct-p2p');
                console.log('🎯 Direct P2P mode enabled - manual connection data exchange');
                
                // Créer une interface pour échanger manuellement les données de connexion
                this.createManualConnectionInterface();
            }

            createManualConnectionInterface() {
                const chatMessages = document.getElementById('chat-messages');
                const manualSection = document.createElement('div');
                manualSection.innerHTML = `
                    <div class="chat-message system">
                        🔧 DIRECT P2P MODE: Manual connection data exchange
                    </div>
                    <div class="chat-message system">
                        ✨ This still works! Just needs copy/paste of connection data
                    </div>
                    <div class="chat-message system">
                        📋 Click Connect to generate connection data to share
                    </div>
                `;
                chatMessages.appendChild(manualSection);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            handleEchoServerMessage(data) {
                // Pour les serveurs echo, nous devons parser différemment
                try {
                    if (data.includes('neuralmix-')) {
                        const message = JSON.parse(data);
                        if (message.to === this.peerId || !message.to) {
                            this.handleSignalingMessage(message);
                        }
                    }
                } catch (e) {
                    console.log('Non-P2P echo message ignored');
                }
            }

            handleSignalingDisconnect() {
                this.websocket = null;
                
                if (this.connectionAttempts < this.maxAttempts) {
                    this.connectionAttempts++;
                    console.log(`🔄 Retrying signaling connection (${this.connectionAttempts}/${this.maxAttempts})`);
                    
                    setTimeout(() => {
                        this.initializeSignaling();
                    }, 2000 * this.connectionAttempts);
                } else {
                    this.updateConnectionStatus('signaling-failed');
                    console.log('❌ Max signaling attempts reached, switching to backup mode');
                    this.enableBackupMode();
                }
            }

            handleSignalingError() {
                this.handleSignalingDisconnect();
            }

            enableBackupMode() {
                // Mode de backup avec affichage manuel des offres/réponses
                this.updateConnectionStatus('backup-mode');
                this.showManualConnectionMode();
            }

            showManualConnectionMode() {
                const chatMessages = document.getElementById('chat-messages');
                chatMessages.innerHTML += `
                    <div class="chat-message system">
                        🔧 BACKUP MODE: Copy/paste connection data manually with your DJ partner
                    </div>
                `;
            }

            async initializeConnection(remotePeerId) {
                this.remotePeerId = remotePeerId;
                this.peerConnection = new RTCPeerConnection(this.config);
                
                // Setup event handlers
                this.peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage({
                            type: 'ice-candidate',
                            candidate: event.candidate,
                            from: this.peerId,
                            to: remotePeerId
                        });
                    }
                };
                
                this.peerConnection.onconnectionstatechange = () => {
                    const state = this.peerConnection.connectionState;
                    this.updateConnectionStatus(state);
                    
                    if (state === 'connected') {
                        this.onConnect();
                    } else if (state === 'disconnected' || state === 'failed') {
                        this.onDisconnect();
                    }
                };
                
                // Create data channel
                this.dataChannel = this.peerConnection.createDataChannel('neuralmix', {
                    ordered: true
                });
                
                this.dataChannel.onopen = () => {
                    console.log('🎵 Data channel opened');
                    this.sendMessage({ type: 'hello', peerId: this.peerId });
                };
                
                this.dataChannel.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.onMessage(data);
                };
                
                // Handle incoming data channels
                this.peerConnection.ondatachannel = (event) => {
                    const channel = event.channel;
                    channel.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.onMessage(data);
                    };
                };
                
                return this.peerConnection;
            }

            async createOffer() {
                const offer = await this.peerConnection.createOffer();
                await this.peerConnection.setLocalDescription(offer);
                
                this.sendSignalingMessage({
                    type: 'offer',
                    offer: offer,
                    from: this.peerId,
                    to: this.remotePeerId
                });
            }

            async handleOffer(offer, fromPeerId) {
                this.remotePeerId = fromPeerId;
                
                if (!this.peerConnection) {
                    await this.initializeConnection(fromPeerId);
                }
                
                await this.peerConnection.setRemoteDescription(offer);
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);
                
                this.sendSignalingMessage({
                    type: 'answer',
                    answer: answer,
                    from: this.peerId,
                    to: fromPeerId
                });
            }

            async handleAnswer(answer) {
                await this.peerConnection.setRemoteDescription(answer);
            }

            async handleIceCandidate(candidate) {
                if (this.peerConnection) {
                    await this.peerConnection.addIceCandidate(candidate);
                }
            }

            sendMessage(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify(data));
                    return true;
                }
                return false;
            }

            sendSignalingMessage(message) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify(message));
                    return true;
                } else {
                    console.log('📤 Signaling not available, queuing message:', message.type);
                    return false;
                }
            }

            async handleSignalingMessage(data) {
                // Ignorer les messages qui ne nous sont pas destinés
                if (data.to && data.to !== this.peerId) {
                    return;
                }
                
                try {
                    switch (data.type) {
                        case 'offer':
                            console.log('📥 Received offer from:', data.from);
                            await this.handleOffer(data.offer, data.from);
                            break;
                        case 'answer':
                            console.log('📥 Received answer from:', data.from);
                            await this.handleAnswer(data.answer);
                            break;
                        case 'ice-candidate':
                            await this.handleIceCandidate(data.candidate);
                            break;
                        case 'register':
                            // Autre peer s'est enregistré
                            break;
                        default:
                            console.log('Unknown signaling message:', data.type);
                    }
                } catch (error) {
                    console.error('Error handling signaling message:', error);
                }
            }

            updateConnectionStatus(state) {
                const statusIndicator = document.querySelector('.status-indicator');
                const statusText = document.getElementById('status-text');
                
                statusIndicator.className = 'status-indicator';
                
                switch (state) {
                    case 'connected':
                        statusIndicator.classList.add('status-connected');
                        statusText.textContent = 'P2P Connected 🔥';
                        break;
                    case 'connecting':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Connecting...';
                        break;
                    case 'signaling-connected':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Signaling Ready';
                        break;
                    case 'signaling-failed':
                        statusIndicator.classList.add('status-disconnected');
                        statusText.textContent = 'Signaling Failed';
                        break;
                    case 'direct-p2p':
                        statusIndicator.classList.add('status-connecting');
                        statusText.textContent = 'Direct P2P Ready ⚡';
                        break;
                    default:
                        statusIndicator.classList.add('status-disconnected');
                        statusText.textContent = 'Disconnected';
                }
            }

            disconnect() {
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                this.onDisconnect();
            }
        }

        // Audio Engine
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.masterGainNode = null;
                this.crossfaderGainA = null;
                this.crossfaderGainB = null;
            }

            async initialize() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master output chain
                this.masterGainNode = this.audioContext.createGain();
                this.masterGainNode.connect(this.audioContext.destination);
                
                // Crossfader gains
                this.crossfaderGainA = this.audioContext.createGain();
                this.crossfaderGainB = this.audioContext.createGain();
                
                this.crossfaderGainA.connect(this.masterGainNode);
                this.crossfaderGainB.connect(this.masterGainNode);
                
                console.log('🎵 Audio engine initialized');
                return this.audioContext;
            }

            createDeckChain(deck) {
                const deckData = {
                    gainNode: this.audioContext.createGain(),
                    eqNodes: {
                        high: this.audioContext.createBiquadFilter(),
                        mid: this.audioContext.createBiquadFilter(),
                        low: this.audioContext.createBiquadFilter()
                    },
                    analyser: this.audioContext.createAnalyser()
                };
                
                // Configure EQ filters
                deckData.eqNodes.high.type = 'highshelf';
                deckData.eqNodes.high.frequency.value = 3200;
                deckData.eqNodes.mid.type = 'peaking';
                deckData.eqNodes.mid.frequency.value = 1000;
                deckData.eqNodes.mid.Q.value = 1;
                deckData.eqNodes.low.type = 'lowshelf';
                deckData.eqNodes.low.frequency.value = 320;
                
                // Configure analyser
                deckData.analyser.fftSize = 2048;
                
                // Connect chain: gain -> EQ -> analyser -> crossfader
                deckData.gainNode.connect(deckData.eqNodes.high);
                deckData.eqNodes.high.connect(deckData.eqNodes.mid);
                deckData.eqNodes.mid.connect(deckData.eqNodes.low);
                deckData.eqNodes.low.connect(deckData.analyser);
                
                if (deck === 'a') {
                    deckData.analyser.connect(this.crossfaderGainA);
                } else {
                    deckData.analyser.connect(this.crossfaderGainB);
                }
                
                return deckData;
            }

            async loadAudioFile(file, deck) {
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                return audioBuffer;
            }

            updateCrossfader(position) {
                // Position: 0 = full A, 1 = full B
                const gainA = Math.cos(position * Math.PI / 2);
                const gainB = Math.sin(position * Math.PI / 2);
                
                this.crossfaderGainA.gain.value = gainA;
                this.crossfaderGainB.gain.value = gainB;
            }
        }

        // Waveform Visualizer
        class WaveformVisualizer {
            constructor(canvas, audioBuffer = null) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.audioBuffer = audioBuffer;
                this.animationId = null;
                
                this.setupCanvas();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            drawWaveform(audioBuffer) {
                if (!audioBuffer) return;
                
                this.audioBuffer = audioBuffer;
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                // Get audio data
                const channelData = audioBuffer.getChannelData(0);
                const samples = channelData.length;
                const samplesPerPixel = Math.floor(samples / width);
                
                // Draw waveform
                this.ctx.strokeStyle = '#a855f7';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    const start = x * samplesPerPixel;
                    const end = start + samplesPerPixel;
                    
                    let min = 1, max = -1;
                    for (let i = start; i < end && i < samples; i++) {
                        const sample = channelData[i];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                    
                    const yMin = (min + 1) * height / 2;
                    const yMax = (max + 1) * height / 2;
                    
                    if (x === 0) {
                        this.ctx.moveTo(x, yMin);
                    }
                    
                    this.ctx.lineTo(x, yMin);
                    this.ctx.lineTo(x, yMax);
                }
                
                this.ctx.stroke();
            }

            drawSpectrum(analyserNode) {
                if (!analyserNode) return;
                
                const bufferLength = analyserNode.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyserNode.getByteFrequencyData(dataArray);
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                this.ctx.clearRect(0, 0, width, height);
                
                const barWidth = width / bufferLength * 2;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * height;
                    
                    const hue = (i / bufferLength) * 360;
                    this.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    this.ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }
        }

        // Main Application
        class NeuralMixApp {
            constructor() {
                this.state = new NeuralMixState();
                this.audioEngine = new AudioEngine();
                this.beatDetector = null;
                this.p2pManager = null;
                this.waveformVisualizers = {};
                this.spectralVisualizer = null;
                
                this.init();
            }

            async init() {
                console.log('🎧 Initializing NeuralMix P2P...');
                
                // Initialize audio engine
                await this.audioEngine.initialize();
                this.beatDetector = new NeuralBeatDetector(this.audioEngine.audioContext);
                
                // Setup UI elements
                this.setupUI();
                this.setupEventListeners();
                this.setupVisualizers();
                
                // Request notification permission
                this.requestNotificationPermission();
                
                // Initialize P2P manager
                this.initializeP2P();
                
                // Start update loops
                this.startUpdateLoops();
                
                console.log('🚀 NeuralMix P2P ready!');
                this.addChatMessage('🎵 NeuralMix P2P initialized', 'system');
                this.addChatMessage('🌐 Real-time P2P signaling active', 'system');
                this.addChatMessage('📡 Ready for cross-network DJ connections', 'system');
            }

            setupUI() {
                document.getElementById('peer-id').value = this.state.peerId;
                
                // Setup deck audio chains
                this.state.decks.a = { ...this.state.decks.a, ...this.audioEngine.createDeckChain('a') };
                this.state.decks.b = { ...this.state.decks.b, ...this.audioEngine.createDeckChain('b') };
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('file-a').addEventListener('change', (e) => this.loadTrack('a', e.target.files[0]));
                document.getElementById('file-b').addEventListener('change', (e) => this.loadTrack('b', e.target.files[0]));
                
                // Play buttons
                document.getElementById('play-a').addEventListener('click', () => this.togglePlay('a'));
                document.getElementById('play-b').addEventListener('click', () => this.togglePlay('b'));
                
                // P2P connection
                document.getElementById('copy-id-btn').addEventListener('click', () => this.copyPeerId());
                document.getElementById('connect-btn').addEventListener('click', () => this.connectToPeer());
                
                // Chat
                document.getElementById('send-chat-btn').addEventListener('click', () => this.sendChatMessage());
                document.getElementById('chat-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendChatMessage();
                });
                
                // Crossfader
                this.setupCrossfader();
                
                // Control sliders
                this.setupControlSliders();
            }

            setupCrossfader() {
                const crossfader = document.getElementById('crossfader');
                const handle = document.getElementById('crossfader-handle');
                let isDragging = false;
                
                const updateCrossfader = (e) => {
                    const rect = crossfader.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width - 50, e.clientX - rect.left - 25));
                    const position = x / (rect.width - 50);
                    
                    handle.style.left = `${x}px`;
                    this.state.mixer.crossfaderPosition = position;
                    this.audioEngine.updateCrossfader(position);
                    
                    // Send to peer
                    if (this.p2pManager) {
                        this.p2pManager.sendMessage({
                            type: 'crossfader',
                            position: position
                        });
                    }
                };
                
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) updateCrossfader(e);
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                crossfader.addEventListener('click', updateCrossfader);
            }

            setupControlSliders() {
                const sliders = document.querySelectorAll('.control-slider');
                
                sliders.forEach(slider => {
                    let isDragging = false;
                    const handle = slider.querySelector('.slider-handle');
                    const deck = slider.dataset.deck;
                    const control = slider.dataset.control;
                    
                    const updateSlider = (e) => {
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
                        const position = x / rect.width;
                        
                        handle.style.left = `${position * 100}%`;
                        this.updateControl(deck, control, position);
                    };
                    
                    slider.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        updateSlider(e);
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) updateSlider(e);
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                });
            }

            updateControl(deck, control, position) {
                const deckData = this.state.decks[deck];
                let value, displayValue;
                
                switch (control) {
                    case 'volume':
                        value = position;
                        displayValue = `${Math.round(position * 100)}%`;
                        deckData.gainNode.gain.value = value;
                        break;
                        
                    case 'high':
                    case 'mid':
                    case 'low':
                        value = (position - 0.5) * 40; // -20dB to +20dB
                        displayValue = `${value > 0 ? '+' : ''}${value.toFixed(1)}dB`;
                        deckData.eqNodes[control].gain.value = value;
                        break;
                }
                
                document.getElementById(`${control}-${deck}-value`).textContent = displayValue;
                
                // Send to peer
                if (this.p2pManager) {
                    this.p2pManager.sendMessage({
                        type: 'control',
                        deck: deck,
                        control: control,
                        value: position
                    });
                }
            }

            setupVisualizers() {
                // Waveform visualizers
                this.waveformVisualizers.a = new WaveformVisualizer(document.getElementById('waveform-a'));
                this.waveformVisualizers.b = new WaveformVisualizer(document.getElementById('waveform-b'));
                
                // Spectral visualizer
                this.spectralVisualizer = new WaveformVisualizer(document.getElementById('spectral-canvas'));
            }

            async loadTrack(deck, file) {
                if (!file) return;
                
                try {
                    const audioBuffer = await this.audioEngine.loadAudioFile(file, deck);
                    this.state.decks[deck].buffer = audioBuffer;
                    
                    // Draw waveform
                    this.waveformVisualizers[deck].drawWaveform(audioBuffer);
                    
                    // Update deck status
                    document.getElementById(`deck-${deck}-status`).textContent = 'LOADED';
                    
                    this.addChatMessage(`🎵 Track loaded on Deck ${deck.toUpperCase()}: ${file.name}`, 'system');
                    
                    // Send to peer
                    if (this.p2pManager) {
                        this.p2pManager.sendMessage({
                            type: 'track-loaded',
                            deck: deck,
                            filename: file.name
                        });
                    }
                    
                } catch (error) {
                    console.error('Error loading track:', error);
                    this.addChatMessage(`❌ Error loading track: ${error.message}`, 'system');
                }
            }

            togglePlay(deck) {
                const deckData = this.state.decks[deck];
                const button = document.getElementById(`play-${deck}`);
                
                if (deckData.isPlaying) {
                    // Stop
                    if (deckData.source) {
                        deckData.source.stop();
                        deckData.source = null;
                    }
                    deckData.isPlaying = false;
                    button.textContent = '▶';
                    button.classList.remove('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'STOPPED';
                } else {
                    // Play
                    if (deckData.buffer) {
                        deckData.source = this.audioEngine.audioContext.createBufferSource();
                        deckData.source.buffer = deckData.buffer;
                        deckData.source.loop = true;
                        deckData.source.connect(deckData.gainNode);
                        deckData.source.start();
                        
                        deckData.isPlaying = true;
                        button.textContent = '⏸';
                        button.classList.add('playing');
                        document.getElementById(`deck-${deck}-status`).textContent = 'PLAYING';
                    }
                }
                
                // Send to peer
                if (this.p2pManager) {
                    this.p2pManager.sendMessage({
                        type: 'play-state',
                        deck: deck,
                        isPlaying: deckData.isPlaying
                    });
                }
            }

            initializeP2P() {
                this.p2pManager = new P2PConnectionManager(
                    this.state.peerId,
                    (message) => this.handleP2PMessage(message),
                    () => this.handleP2PConnect(),
                    () => this.handleP2PDisconnect()
                );
                
                console.log('🌐 P2P Manager initialized with real WebSocket signaling');
            }

            async connectToPeer() {
                const remotePeerId = document.getElementById('remote-peer-id').value.trim();
                if (!remotePeerId) {
                    this.addChatMessage('❌ Please enter a DJ ID', 'system');
                    return;
                }
                
                if (remotePeerId === this.state.peerId) {
                    this.addChatMessage('❌ Cannot connect to yourself', 'system');
                    return;
                }
                
                try {
                    this.addChatMessage(`📞 Initiating P2P connection to: ${remotePeerId}`, 'system');
                    this.addChatMessage('🌐 Using WebRTC with real signaling server', 'system');
                    
                    await this.p2pManager.initializeConnection(remotePeerId);
                    await this.p2pManager.createOffer();
                    
                    this.addChatMessage(`📡 Connection offer sent - waiting for response...`, 'system');
                } catch (error) {
                    console.error('Connection error:', error);
                    this.addChatMessage(`❌ Connection failed: ${error.message}`, 'system');
                    this.addChatMessage('💡 Try: 1) Check internet 2) Verify DJ ID 3) Both click connect', 'system');
                }
            }

            handleP2PMessage(message) {
                switch (message.type) {
                    case 'hello':
                        this.addChatMessage(`👋 Connected to DJ: ${message.peerId}`, 'system');
                        break;
                        
                    case 'crossfader':
                        this.updateRemoteCrossfader(message.position);
                        break;
                        
                    case 'control':
                        this.updateRemoteControl(message.deck, message.control, message.value);
                        break;
                        
                    case 'play-state':
                        this.updateRemotePlayState(message.deck, message.isPlaying);
                        break;
                        
                    case 'chat':
                        this.addChatMessage(`🎧 ${message.text}`, 'peer');
                        break;
                        
                    case 'track-loaded':
                        this.addChatMessage(`🎵 Remote DJ loaded: ${message.filename} on Deck ${message.deck.toUpperCase()}`, 'peer');
                        break;
                }
            }

            handleP2PConnect() {
                this.state.isConnected = true;
                this.addChatMessage('🔥 P2P connection established! Ready to mix!', 'system');
                
                // Show browser notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('NeuralMix P2P Connected!', {
                        body: 'Your DJ session is now live with real-time collaboration',
                        icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%23a855f7"/><text x="50" y="60" text-anchor="middle" fill="white" font-size="25">🎧</text></svg>'
                    });
                }
            }

            handleP2PDisconnect() {
                this.state.isConnected = false;
                this.addChatMessage('⚠️ P2P connection lost - checking reconnection', 'system');
                
                // Tenter une reconnexion automatique
                setTimeout(() => {
                    if (!this.state.isConnected && this.p2pManager) {
                        this.addChatMessage('🔄 Attempting automatic reconnection...', 'system');
                    }
                }, 3000);
            }

            updateRemoteCrossfader(position) {
                const handle = document.getElementById('crossfader-handle');
                const crossfader = document.getElementById('crossfader');
                const rect = crossfader.getBoundingClientRect();
                const x = position * (rect.width - 50);
                
                handle.style.left = `${x}px`;
                this.state.mixer.crossfaderPosition = position;
                this.audioEngine.updateCrossfader(position);
            }

            updateRemoteControl(deck, control, position) {
                // Update UI
                const slider = document.querySelector(`[data-deck="${deck}"][data-control="${control}"]`);
                const handle = slider.querySelector('.slider-handle');
                handle.style.left = `${position * 100}%`;
                
                // Update audio
                this.updateControl(deck, control, position);
            }

            updateRemotePlayState(deck, isPlaying) {
                const button = document.getElementById(`play-${deck}`);
                const deckData = this.state.decks[deck];
                
                if (isPlaying && !deckData.isPlaying) {
                    button.textContent = '⏸';
                    button.classList.add('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'REMOTE PLAYING';
                } else if (!isPlaying && deckData.isPlaying) {
                    button.textContent = '▶';
                    button.classList.remove('playing');
                    document.getElementById(`deck-${deck}-status`).textContent = 'REMOTE STOPPED';
                }
            }

            requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            this.addChatMessage('🔔 Notifications enabled for P2P events', 'system');
                        }
                    });
                }
            }

            copyPeerId() {
                navigator.clipboard.writeText(this.state.peerId).then(() => {
                    this.addChatMessage('📋 DJ ID copied to clipboard', 'system');
                }).catch(() => {
                    this.addChatMessage('❌ Failed to copy DJ ID', 'system');
                });
            }

            sendChatMessage() {
                const input = document.getElementById('chat-input');
                const text = input.value.trim();
                
                if (text && this.p2pManager) {
                    this.p2pManager.sendMessage({
                        type: 'chat',
                        text: text
                    });
                    
                    this.addChatMessage(`You: ${text}`, 'local');
                    input.value = '';
                }
            }

            addChatMessage(text, type) {
                const chatMessages = document.getElementById('chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;
                
                const time = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `<span style="color: #6b7280;">[${time}]</span> ${text}`;
                
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            startUpdateLoops() {
                // Neural analysis loop
                const neuralUpdate = () => {
                    this.updateNeuralAnalysis();
                    requestAnimationFrame(neuralUpdate);
                };
                neuralUpdate();
                
                // Spectral visualization loop
                const spectralUpdate = () => {
                    this.updateSpectralDisplay();
                    requestAnimationFrame(spectralUpdate);
                };
                spectralUpdate();
            }

            updateNeuralAnalysis() {
                let totalConfidence = 0;
                let syncedDecks = 0;
                
                ['a', 'b'].forEach(deck => {
                    const deckData = this.state.decks[deck];
                    if (deckData.isPlaying && deckData.analyser) {
                        const beatData = this.beatDetector.detectBPM(deckData.analyser);
                        if (beatData) {
                            deckData.bpm = beatData.bpm;
                            totalConfidence += beatData.confidence;
                            syncedDecks++;
                        }
                    }
                });
                
                // Update neural sync display
                if (syncedDecks > 0) {
                    const avgConfidence = totalConfidence / syncedDecks;
                    this.state.neural.confidence = avgConfidence;
                    
                    const syncData = this.beatDetector.synchronizeDecks(
                        this.state.decks.a,
                        this.state.decks.b
                    );
                    
                    if (syncData) {
                        document.getElementById('bpm-sync').textContent = 
                            `${this.state.decks.a.bpm || '--'} / ${this.state.decks.b.bpm || '--'}`;
                        document.getElementById('beat-align').textContent = 
                            `${Math.round(syncData.syncQuality)}%`;
                        document.getElementById('neural-confidence').textContent = 
                            `${Math.round(avgConfidence)}%`;
                    }
                }
            }

            updateSpectralDisplay() {
                // Combine both deck spectrums
                const canvas = document.getElementById('spectral-canvas');
                const ctx = canvas.getContext('2d');
                
                if (canvas.width !== canvas.offsetWidth) {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw combined spectrum
                ['a', 'b'].forEach((deck, index) => {
                    const deckData = this.state.decks[deck];
                    if (deckData.isPlaying && deckData.analyser) {
                        const bufferLength = deckData.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        deckData.analyser.getByteFrequencyData(dataArray);
                        
                        const width = canvas.width / 2;
                        const height = canvas.height;
                        const barWidth = width / bufferLength * 2;
                        
                        for (let i = 0; i < bufferLength; i++) {
                            const barHeight = (dataArray[i] / 255) * height;
                            const x = (index * width) + (i * barWidth);
                            
                            const hue = index === 0 ? 280 : 200; // Purple for A, Cyan for B
                            ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                            ctx.fillRect(x, height - barHeight, barWidth - 1, barHeight);
                        }
                    }
                });
                
                // Draw crossfader position
                const crossfaderX = this.state.mixer.crossfaderPosition * canvas.width;
                ctx.strokeStyle = '#ec4899';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(crossfaderX, 0);
                ctx.lineTo(crossfaderX, canvas.height);
                ctx.stroke();
            }
        }

        // Initialize the application
        let neuralMixApp;
        
        document.addEventListener('DOMContentLoaded', function() {
            neuralMixApp = new NeuralMixApp();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (neuralMixApp) {
                Object.values(neuralMixApp.waveformVisualizers).forEach(viz => {
                    viz.setupCanvas();
                });
                neuralMixApp.spectralVisualizer.setupCanvas();
            }
        });
    </script>
</body>
</html>